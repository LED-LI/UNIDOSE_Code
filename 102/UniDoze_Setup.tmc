//******************************************
// Name:        UniDoze_Setup.tmc
//
// Description: UniDoze software
//
//***********************************************************************************************************
// Changes: V2017-12-29 - initial code
//          V2018-07-05 - after Philadelphia show
//           1. review production: V=ok  G=move to global var
//           2. remove PIG types
//           3. remove BACK_PREFILL
//           4. Manual movements
//           5. 9 global parameters for calibration
//           6. functions for cbuoord movents, wait moves (+long +rfs)
//           7. Parameters removed, new functions
//           8. Clear dose calibrator
//           9. Prefill volume check
//          10. Pig replaced
//          12. syringe exists?
//          13. Pig exists?
//          14. Adjust end of rotation before rfs needle
//          15. Move pig fast and high current at end
//          16. moving average for center of vial. not enabled
//          17. CopyToTemporaryGP, RestoreTemporaryGP
//          18. Needle size and length
//          19. Homeing func
//          20. Calibration support
//          21. Reset RST on v_1.45
//          22. parameter for dose calibrator depth
//          23. INIT runs on a new board
//          24. Enable curtain at initDraw, DrawDose, checkDone
//          25. acceleration of piston 10 -> 200
//          26. Report ABORT condition - state 90, set anyError, error 28 -> BitEr_machineAborted
//          27. default syringe
//          28. Enable full fill vial from prefill syringe
//          29. Manual move, one fun and clear GB_MotorIsMoving after Time Out
//          30. Standby current of cap holder changed from 150 to 200
//          31. After detection of syringe or vial pop out, ABORT
//          32. New version each release
//          33. interrupt for syringe pop off in DRAW_DOSE and CHECK_DONE
//          34. double click on DoseCalibratorCheck creates error but enables re-click
//          35. if syringe is bent more than 1.6 mm, do not draw, move to 90 degrees
//  End of V002
//  Not compatible:
//          36. V003001 sense needle to position cap holder
//          37. V003001 U7 senses the crash of dose calibrator in head board. interrupt.
//          38. V003002 check on DoseCalibratorCheck no syringe
//          39. V001003003 syringeIsIn at motor 5 REF
//          40. V001003004 research for needle at capHolder, if error, put in parameter position
//          41. V001003005 serial # of the machine, GB_RobotSerialNumber = 6
//              If the serial # is 001003005,
//              Machine 001= Unidose, HW version 003 = Sensor on cap holder,  Machine # = 005
//          42. move cap to position relative to GB_CapHoldsSyringe before RFS
//          43. V1030007 calibration function 108: findCapHolderAtNeedle
//          44. V1030008 added acceleration to cap holder, rfs starts 150
//          45. V1030009 Interuupts repaired
//          46. V1030010 DI on ABORT, vertical acc = 10,  vertical speed from calibrator = 800, while rotation = 1000
//          47. V1030011 moves from Dose calibrator via top ref switch, or when adjust, via home switch
//          48. V1030012 instead of #47, check tht at the end of movement, touched the left ref rotate sensor
//          49. V1030013 vertical speed from dose calibrator changed from 1200 to 1000
//          50. V1030014 VERTICAL_FOR_NEEDLE = 12075
//          51. V1030015 goto TAMPA Jan 10, 2019
//          52. V1030016
//          53. V1030017 removed hands detected
//          54. V1030018 needle in vial random +/- 0.8 [mm], removed initializeForTesting
//          55. V1030019 changed start of cap holder search fro 120 to 80
//          56. V1040020 cap holder sensor for needle position is off center. GB_NeedleAtCapOffset  = 55
//          57. V1040021 compatibility with machine 3005 (Tampa 2), not use of GB_55
//          58. V1040022 arm into the dose calibrator function 126, max dipper detection 4000
//          59. V1040023 PIG standby current 25 at power up
//          60. V1040024 fixed setCenterOfSeptum for starting operation
//          61. V1040025 Checks before "Fill Dose" that the dipper sensor if not blocked
//          62. V1040026 correct outbank_2 -> GPbank_2  sould not differ
//          63. V1040027 add error for cap bent needle         BitEr_needleBentCap = %1000000000 // bit 512
//          64. V1040028 RFS wait short for second rotation search
//          65. V1040029 Retry syringe pop out at the cap holder
//          66. V1040030 Retry syringe whithin interrupt routine
//          67. V1040031 No more error om bent needles below +/- 3.0 mm
//          68. V1040032 solve problem of cap holder touching rotating head on initialize by setting motor current to 0
//          69. V1040033 check cap sensor before initialize, so that the syringe holder is not there
//          70. V1040034 calculate decap height, relative to loading height
//          71. V1040035 top needle higher at sensor (12000), shorter timeout if miss
//          72. V1040036 longer timeout for rotation rfs 1s --> 2s
//          73. V1040037 variable for needle from bump GB to full entrance
//          74. V1040038 Added syringe #3: DPS
//          75. V1040039 GB_CoordinateStorage 0=RAM only, remove un-neccessaray STGP to save EEPROM
//          76. V1040040 moved init_GB to first run. 
//                       erase EEPROM of errors if "AnyError=1" at INIT_DRAW_DOSE, DRAW_DOSE, CHECK_DONE 
//          77. V1040041 move down for needle recapping
//          78. V1040042 Do not check for home limit sw after running home for PIG holder, goto home always
//          79. V1040043 added pulse divisor to vertical motor, needle hight relative to bump parameter
//          80. V1040044 vibrate rotate to relief bubbles, bump down to 0.04 mL
//          81. V1040045 add wetting of the syringe before drawing liquid
//          82. V1040046 Back to file UniDoze_Setup.tmc
//          83. V1040047 Back to simple wetting and vibrating
//          84. V1040048 corrected fast draw cycle to slow
//          85. V1040049 default kicks=0, repaired drawWaitTime
//          86. V1040050 added gauges 20, 24, draw at fast speed (800), Default draw wait = 100, random needle in vial +- 0.4mm
//          87. V1040051 for adjust cycle go up to absolute hight for short needle
//          88. V1040052 needle interrupt only, no more checkings, always 3 check before error, changed 2 "JC ZE" to "COMP + JC "
//                       function: "func_134:  CSUB retreatFromVial"  if stuck in vial
//                       removed restore and backup subroutines (148, 150)
//          89. V1040053 GP 26 holds the random movement in um. If <=0, sets to 0, 
//                       if >MAX_RANDOM_IN_VIAL sets to RANDOM_um_TO_MOVE_DEF
//          90. V1040054 GP 26 holds the random movement in um. If <=0, sets to 0, 
//                       Parameter for adjustment of hight for needle sensing
//          91. V1040055 Vibrate CAP holder while moving  the syringe into the cap
//          92. V1040056 V1040055 without cap vibration
//          93. V1040057 double the bump to 0.08 ml - canceled later
//          94. V1040058 "push more" piston before, slow draw, shorter wait, no needlee vibration, no bubbles removal, removed SN_003
//          95. V1040059 Try Again: push all previous draw before filling again
//          96. V1040060 quicker "pull more" at the end of draw cycle
//          97. V1040061 correct behaviour of retreat function
//          98. V1040062 squeeze the cap, check it did not fall
//          99. V1040063 when checking cap existance if no cap found, look for bend cap that eliminates insersion into PIG by RFS timeout
//         100. V1040064 when checking cap existance if no cap found, look for bend cap that eliminates insersion into PIG by 3+5 measurements
//         101. V1040065 adjust bubbles issues
//         102. V1040066 adjust bubbles issues - slow more before draw
//         103. V1040067 adjust bubbles issues - fast more before draw
//         104. V1040068 retreat always rotate
//         105. V1040069 initialize after no needle, enable to run initialize after initialize error, adjust for faster
//         106. V1040070 adjust bubbles
//         107. V1040071 repair volume calculation error
//         108. V1040072 draw slower 5mm (was 4), then draw/push slow after 1ml fast draw
//         109. V1040073 draw speed slowed from 1500 to 1200 PPS
//         110. V1040074 high pitch for the piston: 4.8768 mm
//         111. V1040075 high pitch for the piston: 4.8768 mm + fast more + alow more volume for prefill & adjust
//         112. V1040076 back to slow "more" at the start of draw, slower push (re-try), no squeezinng the piston, 3s -> 2s wait time, 
//                       wait time at least for 1 ml, repaired bug of not waiting after small dozes.
//         113. V1040077 check if the cap fell down 1mm above the squeeze cap hight. adjusted for taiwan
//         114. V1040079 check needle length for exit from cap. Adjusted for taiwan
//         115. V1040080 Add more syringes
//         116. V1040081
//         117. V1040082 check cap. more back speed according to gauge and length.
//         118. V1040083 moved position of pig holder out when squeezing cap after dose calibrator.
//         119. V1040084 FOR TAIWAN MACHINE. Syringe cap is transparent, will not detect. I the future willcompare syringe type.
//         120. V1040085 added BD 2ml syringe, with higher movement up afted de-capping. if Terumo 2.5ml, do not check fallen cap.
//         121. V1040086 set hight of needle at cap. adjusted by needle length parameter
//                       SGP     GB_syringeWOcapInPIG, GPbank_2, clr  at clear all errors
//         122. V1040087 removed STGP for GB_adjustmentsTotal
//         123. V1040088 Bump amount 46 -> 60 microL (BUMP_DOWN_REL_uL)
//         124. V1040089 cancel: Bump amount 60 -> 46 microL (BUMP_DOWN_REL_uL), 
//                       less currrent when moving into dose calibrator :150
//                       Added new function: func_150: ExtractFromDoseCalibrator  and error BitEr_stuckInDoseCalibrator
//                       The function will run only if lower than 20000
//         125. V1040090 fast speed for withdraw (1800) and more delay after draw, draw to full syringe in full speed and return piston to requested volume
//         126. V1040092 fast speed for withdraw (1800) and more delay after draw (removed the draw full syringe)
//         127. V1040096 debubble #2 - added a second fast draw (appended to V1040092)
//         128. V1040097 bypass the PullAir percentage and use 100% all the time 
//         129. V1040098 Priming syringe - #1 fill and empty syringe once before final draw
//         130. V1040099 Priming syringe - #2 fill and empty syringe (shake) 3 times and once more slow
//         131. V1040100 Priming syringe - #3 shake and never close all the way
//         132. V1040101 Priming syringe - #4 
//         133. V1040102 Priming syringe - #5 with breating
//
//***********************************************************************************************************

// this file 2022-12-29-V400102-UniDoze-Setup-debubble-Priming_with_breathing.tmc

CURRENT_VERSION      =  1040102

//*******************************
//Definitions of motor numbers
//*******************************

M_verticalMotor    = 0    // up down
M_pigHolderMotor   = 1    // rotate head
M_capHolderMotor   = 2    // hold syringe
M_pistonMotor      = 3    // fill syringe
M_headRotateMotor  = 4    // move pig
M_headRef_sensors  = 5    // left sensor" "syringe popped out"
                          // right sensor "dose calibrator dipper" anti crash (1=dipper seen)

//************************
//Definitions of Inputs
//************************

In_VialInPlace         = 0 //
In_VerticalHomeSensor  = 1 // Home switch input for motor 0
In_spare_2             = 2 // was In_handDetected
In_CapHolderHomeNeedle = 3 // cap holder stops on needle
In_spare_4             = 4 // was syringe is in place;  1 = not in place
In_VailShieldOpen      = 5 // the solenoid shield is open
In_NeedleInPosition    = 6 // 0 = Needle not in place to enter vail; 1 = needle on the sensor
In_PigInPlace          = 7 // The Pig is in place

//*******************************************
//Definitions of Outputs
//*******************************************

Out_GreenLED      = 0 //  yellow color when both red and green are on
Out_RedLED        = 1 //
//Out_needlePower   = 2 //  power for LED of needle sensor
      //Out_ShieldVail    = 3 //  1A  rotating solenoid - machines 1&2
DCtoDC_power_0    = 3   // was Curtain_power // machine 3+
Out_spare_4       = 4   // was vial_lock
Out_spare_5       = 5   // was for LED 24V
MotorUpRelease    = 6 // - relay shorts vertical motor to stop w/o power // machine 3+
     //MotorUpRelease    = 7 //  1A  Up motor un-short - machines 1&2
Out_ShieldVail    = 7 //  1A  rotating solenoid - machine 3+

//***********
// Defines
//***********
PIG_IS_LOADED        =    1
VIAL_IS_LOADED       =    1
VIAL_IS_UNSHIELDED   =    1
HAND_IS_IN           =    1
SYRINGE_IN_PLACE     =    1
 // SYRINGE_IN_PLACE     =    0  // V002
ANY_ERROR_EXISTS     =    1
PRE_FILL_REQUEST     =    1
ADJUST_STATE         =    1
TRY_AGAIN_STATE      =    1
CORRECT_ACTIVITY     =    1
WAIT_TICKS_200ms     =   20 // [200ms]
WAIT_TICKS_CAP       =  100  // [ 2s]
WAIT_TICKS_SHORT     =  200  // [ 2s]
WAIT_TICKS           = 1000  // [10s]
WAIT_TICKS_LONG      = 1500  // [15s]
PIG_HOLDER_AT_HOME   =    1
CAP_HOLDER_AT_HOME   =    1
BELOW_VIAL_COORD     =    7
ABOVE_CAP_COORD      =    8
LED_ON               =    1
LED_OFF              =    0
PIG_WAS_REPLACED     =    1
PIG_NOT_REPLACED     =    0
DEF_DRAW_WAIT_TIME   =  300 // 200 // 300 /// 3s // 200 // // 2s // 1s // 200 // default for 25 mm needle length and 22 Gauge = 2[s]
AT_HOME              =    1
DEFAULT_NEEDLE_LENGTH =  25
DEFAULT_DRAW_VOLUME  = 1000  // 1[ml]
CAP_SENSOR_BLOCKED   =    0
DIPPER_IS_BLOCKED    =    1
IN_HOME_CAP_HOLDER_MOTOR =1

//********************************
// User variables map (bank 2)
//********************************
// prameters from Trinamic to PC:
//********************************

GB_currentVersion          =   0    // Current SW version

GB_Syringe_Type            =   1    //
  DEFAULT_SYRINGE_TYPE  = 2
  BD_syringe            = 1
  HenryShine_syringe    = 2
  DPS_syringe           = 3 
  Terumo_2_5ml_syringe  = 4    
  Terumo_6ml_syringe    = 5     // 6ml  Taiwan
  BD_2ml_syringe        = 6
  other_7               = 7

GB_DrawWaitTime            =   2  // here we calculate the actual time
GB_InitDone                =   3  // INIT (func 0) done. starts automaticaly
GB_HomingDone              =   4  // FIND_HOME, only at power up
// SW states
GB_CurrentState            =   5  // defines the current state of the process
WAITING_INIT_DRAW_DOSE = 10       // this the state after the power up as well
RUNNING_INIT_DRAW_DOSE = 20
WAITING_DRAW_DOSE      = 30       // at this state it is possible as well to run INIT_DRAW_DOSE (6)
RUNNING_DRAW_DOSE      = 40
WAITING_CHECK_DONE     = 50
RUNNING_CHECK_DONE     = 60
STOPPED_ON_ERROR       = 70
STOPPED_TIME_OUT       = 80
ABORTED                = 90


GB_RobotSerialNumber   =    6        // (1030006)  1= unidose, 03= HW ver,  0006= machine #)
//SN_003                 = 3005        // tampa 2 machine has not GB_55 parameter

// the following 3 global parameters will appear at motor 0 (vertical)
//  GB_VerticalHomePos      =   7    // position for rotation adjustment
//  GB_LoadingHight         =   8    // syringe loading
//  GB_BumpPosVert          =   9    // needle touches the vial rubber

GB_needleLength            =  10    // 25, 16 [mm]
GB_needleGauge             =  11    // 21, 22, 23 [gauge]
GB_cyclesTotal             =  12    //
GB_adjustCycle             =  13    //
GB_readyToDraw             =  14    // after verifyReady
GB_initialVolume           =  15    // including prefill + withdraw + adjust
GB_MotorIsMoving           =  16    //
// the following global parameter will appear at motor 0 (vertical)
// GB_InDoseCalibrator     =  17    // Depth of dose calibrator
GB_HomingShortDone         =  18    //

//*********************************
//  prameters from PC to Trinamic:
//*********************************

GB_UnitsToMoveManual       =  19    // for manual movement, put here the microMeter or Mili Degree to move (+/-)
GB_ShowOveride             =  20    // 1 = will not check for pig removal (GP 28  error)
GB_airToPullBefore         =  21    // in Percentage. Normal is 70%. Should be reduced when vial is full
GB_activityIsCorrect       =  22    // the results from the DozeCalib are OK {1 = good, 0 = no}
GB_preFillVolume           =  23    // [micro Litter]
GB_preFillRequest          =  24    // prefill=1   noprefill=0
GB_motorNumForHome         =  25    // 0=vertical, 1=pig, 2=cap, 3=piston, 4=rotate
// the following global parameter will appear at motor 4 (rotate)
//GB_microMeterRandom        =  26    // +/- random insertion into vial in uM
GB_microLtoWithdraw        =  27    // microL to withdraw. If prefill put the new amount.
                                    // if put back volume into vial, the number will be negative
//*********************************************
// Errors
//*********************************************

GB_errors_Ver002           =  28
 // bit errors for parameter 28
    BitEr_pigWasNotReplaced   = %00000000001 // bit    1  left ref sensor
    BitEr_syringePoppedOut    = %00000000010 // bit    2  syringe popped out during cycle
    BitEr_VialPoppedOut       = %00000000100 // bit    4  vial popped out during cycle
    BitEr_PigPoppedOut        = %00000001000 // bit    8
    BitEr_pigHolderNotAtHome  = %00000010000 // bit   16
    BitEr_machineAborted      = %00000100000 // bit   32
    BitEr_needleBentRotate    = %00001000000 // bit   64
    BitEr_doseCalibDipper     = %00010000000 // bit  128
    BitEr_DipperSensorBlocked = %00100000000 // bit  256
    BitEr_needleBentCap       = %01000000000 // bit  512
    BitEr_capSensorBlocked    = %10000000000 // bit 1024  check that the vertical did not move down on the cap holder
    BitEr_bentCapBeforePIG    = %100000000000 // bit 2048  before entering syringe into pig, found bent syring with cap

GB_any_Error               =  29    // any error occured

//  motor errors for each of parameters 30-34
    BitEr_leftRefSensor         =  %00000001 // bit   1  left ref sensor
    BitEr_rightRefSensor        =  %00000010 // bit   2  right ref sensor
    BitEr_homeNotFound          =  %00000100 // bit   4  did not find home
    BitEr_TimeOut               =  %00001000 // bit   8
    BitEr_calibrationErr        =  %00010000 // bit  16
    BitEr_retreatFromVialErr    =  %00100000 // bit  32
    BitEr_stuckInDoseCalibrator =  %01000000 // bit  64
    BitEr_m7                    =  %10000000 // bit 128

GB_errors_M_verticalMotor   = 30   
GB_errors_M_pigHolderMotor  = 31
GB_errors_M_capHolderMotor  = 32
GB_errors_M_pistonMotor     = 33
GB_errors_M_headRotateMotor = 34

//****************
// special errors
//****************
GB_errors_SyringeIsIn           = 35  // FIND_HOMES error or INIT_DRAW_DOSE, Syringe is in the system
GB_errors_needleInVial          = 36  // set while the needle is in the vial, cleared when out again
GB_errors_SyringeMissing        = 37  // DRAW_DOSE error, missing the syringe
GB_errors_VialMissing           = 38  // DRAW_DOSE error, missing the vial
GB_errors_PigMissing            = 39  // DRAW_DOSE error, missing the pig
GB_errors_volumeExceedsLimits   = 40
GB_errors_prefillExeedsLimit    = 41  // **New
GB_errors_vialShieldNotOpen     = 42

GB_errors_findHome              = 43
 // bit errors for parameter 43
    BitEr_syringeIsInwhileFindHome      =  %00000001 // bit   1
    BitEr_pigHolderIsInWhileFindHome    =  %00000010 // bit   2
    BitEr_capHolderIsInWhileFindHome    =  %00000100 // bit   4
    BitEr_h3                            =  %00001000 // bit   8
    BitEr_h4                            =  %00010000 // bit  16
    BitEr_h5                            =  %00100000 // bit  32
    BitEr_h6                            =  %01000000 // bit  64
    BitEr_h7                            =  %10000000 // bit 128

GB_errors_wrong_PC_command      = 44
 // bit errors for parameter 44
    BitEr_expecting_GP5_10_OR_30        =  %00000001 // bit   1
    BitEr_expecting_WAITING_DRAW_DOSE   =  %00000010 // bit   2
    BitEr_expecting_WAITING_CHECK_DONE  =  %00000100 // bit   4
    BitEr_errorAdjustOrAgain            =  %00001000 // bit   8
    BitEr_c4                            =  %00010000 // bit  16
    BitEr_c5                            =  %00100000 // bit  32
    BitEr_c6                            =  %01000000 // bit  64
    BitEr_c7                            =  %10000000 // bit 128

// the following 6 global parameters will appear at their motor
// GB_PigBelowSyringe              = 45   // pig is under the syringe
// GB_RecapPositionPig             = 46   // to hold the cap for recap
// GB_CapHoldsSyringe              = 47   // cap holder is under the syringe
// GB_PistonHomePos                = 48   // for empty syringe
// GB_HeadRotateHomePos            = 49   // center of syringe cap
// GB_CenterOfVial                 = 50   // at the top

//********************
//********************
// Syringe parameters
//********************
//********************

// Syringe_1 = BD 3ml syringe
Max_Volume_1         =  3000  // [uL]
microL_per_100mm_1   =  5865  //6035
Syring_Length_1      = 50000  // [um]
Limit_for_Prefill_1  =  2500  // [uL]
LoadingDistance_1    =  1500  // [usteps]6

// Syringe_2 = Henry Shine
Max_Volume_2         =  3000  // [uL]
microL_per_100mm_2   =  6417  //  6346
Syring_Length_2      = 50000  // [um]
Limit_for_Prefill_2  =  2500  // [uL]
LoadingDistance_2    =  1500  // [usteps]

// Syringe_3 = DPS
Max_Volume_3         =  3000  // [uL]
microL_per_100mm_3   =  5837
Syring_Length_3      = 50000  // [um]
Limit_for_Prefill_3  =  2500  // [uL]
LoadingDistance_3    =  1500  // [usteps]

// Syringe_4 = Terumo_2_5ml_syringe
Max_Volume_4         =  2500  // [uL]
microL_per_100mm_4   =  6417
Syring_Length_4      = 50000  // [um]
Limit_for_Prefill_4  =  2000  // [uL]
LoadingDistance_4    =  1500  // [usteps]

// Syringe_5 = Terumo_6ml_syringe
Max_Volume_5         =  6000  // [uL]
microL_per_100mm_5   = 13196
Syring_Length_5      = 50000  // [um]
Limit_for_Prefill_5  =  4500  // [uL]
LoadingDistance_5    =  1500  // [usteps]

// Syringe_6 = BD_2ml_syringe
Max_Volume_6         =  2000  // [uL]
microL_per_100mm_6   =  6060
Syring_Length_6      = 50000  // [um]
Limit_for_Prefill_6  =  1500  // [uL]
LoadingDistance_6    =  1500  // [usteps]

// Syringe_7 = Other_7
Max_Volume_7         =  3000  // [uL]
microL_per_100mm_7   =  6000
Syring_Length_7      = 50000  // [um]
Limit_for_Prefill_7  =  2500  // [uL]
LoadingDistance_7    =  1500  // [usteps]

// current syringe
// GB_Max_Volume_current        = 160
// GB_microL_per_100mm_current  = 161
// GB_Syring_Length_current     = 162
// GB_Limit_for_Prefill_current = 163

// GB_adjustNeedleSensingHightMM  =  51
GB_tryAgainCycle    = 52
// GB_squeezeCapHeight    = 53
GB_54               = 54

// the following global parameters will appear at motor 2 (cap holder)
// GB_needleAtCapOffset         = 55     // offset from cap sensor finds needle position to true center of cap holder
// 55 is the last GB that can also be stored permanently in the EEPROM

// the following global parameters will appear at motor 0 (vertical)
// GB_LoadingDistance_current   = 56     // future option, not used

//******************
//******************
// motor parameters
//******************
//******************

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// GB_Motor_0 = M_verticalMotor
   verticalFeedPerRevolution       =   254  //  [0.1mm]
   verticalMicrosteps              =    16
   verticalStepsPerRev             =   200
   verticalMicroStepsPerRev        = verticalMicrosteps * verticalStepsPerRev  // = 3200 [uS/rev]
   verticalMicroStepsPerMM         = verticalMicroStepsPerRev * 10 / verticalFeedPerRevolution // = 126
   VERTICAL_POS_COORD              =    10

GB_VerticalHomePos            =   7         // position for rotation adjustment  ~1100
GB_LoadingHight               =   8         // syringe loading  ~700
GB_BumpPosVert                =   9         // needle touches the vial rubber  ~9490
GB_InDoseCalibrator           =  17         // Depth of dose calibrator ~ 38000
GB_adjustNeedleSensingHightMM =  51         // mm to move down the hight of needle sensing. for special bump hight
GB_squeezeCapHeight           =  53

   DECAP_HEIGHT_DELTA              = -5600 // -5040 // 40 [mm] decap height & needle check relative to loading height
   VERTICAL_BACK_TO_CENTER         =  -945  // move head down into cap, where we adjust back to center
   VERTICAL_CAP_VIBRATE_DELTA      =  3500  // [um]
   VERTICAL_FOR_ROTATION           = 14500  // ABS
   VERTICAL_FOR_RETRETE            = 24000  // go lower to exit syringe from sheet metal when rotating
   VERTICAL_FOR_NEEDLE_DELTA       =  2900  // from bump, parameter 9
   ABOVE_BUMP                      =     8  // insert neddle to this hight [mm]
   VERTICAL_IN_VIAL_DELTA          = -verticalMicroStepsPerMM * ABOVE_BUMP  // ~1000 usteps = 8.0 [mm] from bump hight into the vial, to get most of the fluid
   STOP_CHECK_DIPPER_VERTICAL      =  4000  // 3000  //  delta from deepest vertical in dose (GP 17)
   ABOVE_PIG                       = -9300  // ABS
   IN_PIG                          =  2500  // ABS
   UP_FOR_SENSOR_ABS               =  -350  // where to go up from dose calibrator to meet rotate sensor for interrupt
//   DETECT_CAP_HIGHT                = -5500
   DETECT_CAP_HIGHT_REL            = -verticalMicroStepsPerMM 
   ABOVE_SQUEEZE_CAP               = -6000
   MIN_DEPTH_FOR_EXTRACT           =  20000
   HIGHT_TO_GET_SOME_AIR           =  13825

   MAX_CURRENT_VERT                =   200
   MAX_CURRENT_VERT_HIGH           =   255
   MAX_CURRENT_VERT_INTO_CALIBRATOR  = 150
   STBY_CURRENT_VERT               =   100
   MAX_POS_SPEED_VER_ROT           =  1300  // needs same speed for vertical and rotation for coordinated move
   MAX_POS_SPEED_VER_INTO_CAP      =   600  //
   MAX_POS_SPEED_VER_TO_VIAL       =   200
   MAX_POS_SPEED_VER_TO_PIG        =   800
   MAX_POS_SPEED_VER_DOWN          =  1200
   MAX_POS_SPEED_VER_HIGH          =  1000
   MAX_POS_SPEED_VER_RETREAT       =   400
   ACC_VERT                        =    10  // 20  // show 10
   ACC_VERT_HIGH                   =    40
   SEARCH_SPEED_VERT               =   400  // 400
   SWITCH_SPEED_VERT               =   400  //  80

GB_needleLengthInMicroSteps   = 130        // verticalMicroStepsPerMM * GB_needleLength = 5039 [steps] for 40 [mm]
GB_lastCapRefPosition         = 131
GB_defaultNeedleLengthInMicroSteps = 132
GB_vertical133                = 133
GB_vertical134                = 134

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// GB_Motor_1 = M_pigHolderMotor
   pigGearRatio                 =    10
   pigMicrosteps                =    16
   pigStepsPerRev               =   200
   DegreePerRev                 =   360
   pigMicroStepsPerRev          = pigGearRatio * pigMicrosteps * pigStepsPerRev  // = 32000
   pigMicrostepsPerDeg          = pigMicroStepsPerRev / DegreePerRev // 89
   PIG_POS_COORD                =     1
GB_PigBelowSyringe   = 45            // pig is under the syringe ~5100
   STBY_CURRENT_PIG             =    25
   STBY_CURRENT_PIG_HIGH        =   150
   MAX_POS_SPEED_PIG            =   500
   ACC_PIG                      =    10 //  10
   SEARCH_SPEED_PIG             =   350 // 200
   SWITCH_SPEED_PIG             =    20 //  101
   MAX_CURRENT_PIG              =   128
   MAX_CURRENT_PIG_HIGH         =   200
GB_RecapPositionPig   = 46           // to hold the cap for recap   ~3800
   MUL_PIG_FASTER               =     1 // multiply pig speed to go fast
   SQUEEZE_CAP_ON_PIG_DELTA     =   400 // 640 2021-05-06

GB_135                       = 135
GB_136                       = 136
GB_137                       = 137
GB_138                       = 138
GB_139                       = 139

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// GB_Motor_2 = M_capHolderMotor
   capGearRatio              =    10
   capMicrosteps             =    16
   capStepsPerRev            =   200
   capRotationRadius         =   125  // mm
   capMicroStepsPerRev       = capGearRatio * capMicrosteps * capStepsPerRev    // =32000
   capMicrostepsPerDeg       = capMicroStepsPerRev / DegreePerRev // 89
   capMicroStepsPerMM        = capMicroStepsPerRev /(2 * capRotationRadius * 314 / 100)  // 40 [us/mm]
   CAP_POS_COORD             =     2
GB_CapHoldsSyringe    = 47   // cap holder is under the syringe  ~2400
   STBY_CUR_CAP              =    25
   STBY_CUR_CAP_HIGH         =   200
   MAX_POS_SPEED_CAP         =   400
   ACC_CAP                   =    60 // 5
   CAP_HOLDER_RELATIVE_RFS   =    40 // 80 //120 // 180
GB_NeedleAtCapOffset  = 55     // offset from cap sensor finds needle position to true center of cap holder 
   SEARCH_SPEED_CAP          =   400
   SWITCH_SPEED_CAP          =    20
   SEARCH_SPEED_CAP_SLOW     =    50 // 20
   SWITCH_SPEED_CAP_SLOW     =    30
   WAIT_CAP_REF              =    70 // 0.7s // 160 // 1.8 [S]
   MAX_CURRENT_CAP           =   128
   LIMIT_UM_BENT_NEEDLE_CAP  =  3000 // 2000 // [um]
   limitCapBentMicroS        = capMicroStepsPerMM * LIMIT_UM_BENT_NEEDLE_CAP / 1000  // 3.00 [mm] // 2.00 [mm] = 81 us
   VIBRATE_CAP_uM            =   300  //  +/- 0.3 mm at the end of the cap holder
   STEPS_FOR_CAPS_SENSING    =   160 

GB_capMicroStepsPerMM        = 140
GB_limitCapBentMicroS        = 141
GB_NeedleCapError            = 142   // error of needle at capholder position
GB_143                       = 143
GB_144                       = 144


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// GB_Motor_3 = M_pistonMotor
   pistonFeedPerRevolution       =  4877 /// from version 74 // 2420  // micrometer
   pistonStepsPerRev             =   200
   pistonMicrosteps              =    16
   pistonMicroStepsPerRev        = pistonMicrosteps * pistonStepsPerRev  // = 3200 [uS/rev]
   pistonMicroStepsPerMM         = 1000 * pistonMicroStepsPerRev / pistonFeedPerRevolution // = 1322
// GB_microL_per_100mm_current    =  6522
   PISTON_POS_COORD              =     3
   GB_PistonHomePos       = 48         // for empty syringe ~1300

//   BUMP_DOWN_REL                 =   500 /// 1000 // 0.05 mL // 1600 // tampa  // 800 // 0.04 mL 
//   PISTON_BACKLASH               =     0 // (done) will be added to the "70%" push back = 60[uL]
//   PISTON_MORE                   =  4000 /// 6000 /// 12000 // 8000 // (done) to the draw and then pushed back    = 0.6 mL
//   ADD_FOR_PREFILL               =   830 ///  1666 // (done) add 0.08 mL
//   PUSH_PISTON_MORE              =   300 ///   600 // 0.03 mL // 15 uL = 0.015 mL

   BUMP_DOWN_REL_uL              =    60  // 46 ///  
//   PISTON_BACKLASH_uL            =     0 //  (done) will be added to the "70%" push back = 60[uL]
   PISTON_MORE_uL                =   368 /// to the draw and then pushed back    = 0.6 mL
   ADD_FOR_PREFILL_uL            =    76 ///  1666 // (done) add 0.08 mL
   PUSH_PISTON_MORE_uL           =     0 /// 28 ///   600 // 0.03 mL // 15 uL = 0.015 mL
   BUBBLES_PULL_uL               =   700 // 0.7 ml
   MIN_DRAW_PISTON_uL            =  1000 // uL
   MINIMUM_DRAW_VOLUME_uL        =   100  // not less than 0.1 ml
   MINIMUM_DRAW_PREFILL_uL       =   100  // not less than 0.1 ml


   MAX_POS_SPEED_PIST            =   600 //   800
   MAX_POS_SPEED_PIST_DRAW       =  1800 /// 1200 // 1500
   MAX_POS_SPEED_PIST_TRYAGAIN   =   600 /// 1200 //  800
   MAX_POS_SPEED_PIST_BUBBLE     =  1800 /// 1500
   MAX_POS_SPEED_PIST_BUBBLE_BACK =  800 /// 1200
   MAX_POS_SPEED_PIST_MORE       =   200 //// 1800 ///  100 /// 200 // 1500 //  200
   MAX_POS_SPEED_PIST_MORE_BACK  =   600 /// 1200
   SEARCH_SPEED_PIST             =   400 /// 800
   SWITCH_SPEED_PIST             =   100

   ACC_PIST                      =   200
   STBY_CURRENT_PIST             =    25
   MAX_CURRENT_PIST              =   128
   MAX_PIST_IN_USTEPS            =   29650 // mesured - with curent hardware 

   WAIT_TICKS_PUSH_AIR           =    50  //  [0.5s]
   WAIT_TICKS_BUBBLES            =   100 //   [1s]
   WAIT_TICKS_BUBBLES_BACK       =    20  //  [0.2s]
 
GB_tempPistonCalculation_uL       = 145
GB_pistonMicroStepPer100microL = 146 // 10000 * pistonMicroStepsPerMM / GB_microL_per_100mm_current = 2190
GB_minDrawPistonTemp_uL        = 147 //
GB_pisonLocation               = 148
GB_149                         = 149


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// GB_Motor_4 = M_headRotateMotor
   rotateGearRatio               =     20
   rotateMicrosteps              =     16
   rotateStepsPerRev             =    200
   needleRotationRadius          =    230  // mm
   rotateMicroStepsPerRev        = rotateGearRatio * rotateStepsPerRev * rotateMicrosteps // = 64000
   rotateMicroStepsPerDeg        = rotateMicroStepsPerRev / DegreePerRev // 178
   rotateMicroStepsPerMM         = rotateMicroStepsPerRev / (2 * needleRotationRadius * 314 / 100) //  44 [us/mm]
   
   ROTATE_POS_COORD              =      4
GB_HeadRotateHomePos    = 49          // center of syringe cap   ~ 160
   HEAD_ROTATE_NEEDLE_SEARCH     =  31920 // 32000 // relative to cap place.
   NEEDLE_TO_HOME                =   1000 // -31400
                                                   //  later will move more by GB_HeadRotateHomePos
   HEAD_ROTATE_CALIBRATOR_CHECK  =  16000 // points to the right 90 degrees
   FROM_TOP_TO_RIGHT             = -16000
GB_CenterOfVial         = 50           // at the top  ~ 32150
   AVERAGE_CENTER_VIAL_WEIGHT    =    100
   RE_CALC_CENTER_OF_VIAL_LIMIT  =     60
   ACC_ROT                       =     20
   STBY_CUR_ROTATE_LOW           =     10  // after ABORT
   STBY_CUR_ROTATE               =    100  // normal
   STBY_CUR_ROTATE_HIGH          =    200  // while syringe loading
// MAX_POS_SPEED_VER_ROT         =   1300  // needs same speed for vertical and rotation for coordinated move
   SEARCH_SPEED_ROT              =    100
   SWITCH_SPEED_ROT              =     50
   SEARCH_SPEED_ROT_SLOW         =     20
   SWITCH_SPEED_ROT_SLOW         =     10 // 20
   WAIT_NEEDLE_REF_FIRST         =     90 // 0.8 [S]
   WAIT_NEEDLE_REF_SECOND        =    550 // 5.5 s
   MAX_CURRENT_ROT               =    128
GB_microMeterRandom     = 26    // +/- random insertion into vial in uM
   RANDOM_um_TO_MOVE_DEF         =    300 // 0.3mm the needle enters the vial at random location +- RANDOM_um_TO_MOVE_DEF
   MAX_RANDOM_IN_VIAL            =    700 // uM = 0.7mm
   LIMIT_UM_BENT_NEEDLE          =   3000 // 1650 // [um]
   limitNeedleBentMicroS         =  rotateMicroStepsPerMM * LIMIT_UM_BENT_NEEDLE / 1000  // 3.0 [mm] // 2.0 [mm] = 88 us
   NUMBER_OF_KICKS               =      0
   ROTATE_BUBBLES_uM             =   1000  //  +/- 1 mm at the end of the needle

GB_lastTopRefPosition         = 150
GB_rotateMicroStepsPerMM      = 151
GB_limitNeedleBentMicroS      = 152
GB_NeedleVialError            = 153
GB_154                        = 154

// current syringe
GB_Max_Volume_current        = 160
GB_microL_per_100mm_current  = 161
GB_Syring_Length_current     = 162
GB_Limit_for_Prefill_current = 163

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// bubbles
GB_numberOfKicksTemp             =  182
GB_                              =  183  
GB_184                           =  184  
GB_185                           =  185   
GB_186                           =  186    
GB_drawCycleTime                 =  187    // calculates the time of the cycle

GB_PigWasReplaced                =  190    //
GB_inHomeCapHolderMotor          =  191    // signals when to check 3 times for syringe poped out
GB_MulCenterOfVial               =  192    // for running average calculations
GB_adjustmentsTotal              =  193
GB_TouchedLeftRef                =  195
GB_dipperInterruptHight          =  196
GB_syringeWOcapInPIG             =  197    // will be cleared on the next cycle 
GB_retreatMovementComplete       =  198    // signals end of retreat movement. will be cleared on the next cycle
GB_InterruptCount                =  255    // temorary variable 5


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//******************
// CODE STARTS HERE
//******************

// subroutines initialize from PC  // "starting address":

FUNC_0:    CSUB FIRST_RUN        //  will run on power ON
           JA   BACK_GROUND_PROCESS
FUNC_2:    CSUB FIND_HOMES       //  Will test all axis and sensors
           JA   BACK_GROUND_PROCESS
FUNC_4:    JA   CLEAR_ALL_ERRORS //  resets all errors to start. JA because of the RST function that clears stack any way
           JA   BACK_GROUND_PROCESS
FUNC_6:    CSUB INIT_DRAW_DOSE   //  Run the initial setup, detect if there is a initial volume in the system
           JA   BACK_GROUND_PROCESS
FUNC_8:    CSUB DRAW_DOSE        //  Draw the requested activity
           JA   BACK_GROUND_PROCESS
FUNC_10:   CSUB CHECK_DONE       //  ok, put the syringe in PIG
           JA   BACK_GROUND_PROCESS
func_12:   CSUB ABORT            //  stop all motors and program
           JA   BACK_GROUND_PROCESS
func_14:   CSUB VERIFY_READY_DRAW //  checks if the vial' syrine and pig are ready to draw
           JA   BACK_GROUND_PROCESS
FUNC_16:   CSUB INIT             //  Initialize parameters.
           JA   BACK_GROUND_PROCESS
func_18:   CSUB FIND_HOMES_SHORT
           JA   BACK_GROUND_PROCESS
func_20:   CSUB HomeCalibration
           JA   BACK_GROUND_PROCESS
func_22:   CSUB LEDS_OFF
           JA   BACK_GROUND_PROCESS
func_24:   CSUB RED_ON
           JA   BACK_GROUND_PROCESS
func_26:   CSUB GREEN_ON
           JA   BACK_GROUND_PROCESS
func_28:   CSUB YELLOW_ON
           JA   BACK_GROUND_PROCESS

// for FUNC_2 (FIND_HOMES)

func_30:   CSUB positionVerticalMotor  // will not search bottom side. for debugging
           JA   BACK_GROUND_PROCESS
func_32:   CSUB homePigHolderMotorBoth
           JA   BACK_GROUND_PROCESS
func_34:   CSUB homeCapHolderMotorBoth
           JA   BACK_GROUND_PROCESS
func_36:   CSUB homePistonMotorBoth
           JA   BACK_GROUND_PROCESS
func_38:   CSUB PositionHeadRotateMotor
           JA   BACK_GROUND_PROCESS
func_40:   CSUB verticalMotorTOerr
           JA   BACK_GROUND_PROCESS
func_42:   CSUB pigMotorTOerr
           JA   BACK_GROUND_PROCESS
func_44:   CSUB capHolderMotorTOerr
           JA   BACK_GROUND_PROCESS
func_46:   CSUB pistonMotorTOerr
           JA   BACK_GROUND_PROCESS
func_48:   CSUB headRotateMotorTOerr
           JA   BACK_GROUND_PROCESS
func_50:   CSUB verticalMotorTOerr
           JA   BACK_GROUND_PROCESS
func_52:   CSUB capHolderMotorTOerr
           JA   BACK_GROUND_PROCESS
func_54:   CSUB pistonMotorTOerr
           JA   BACK_GROUND_PROCESS
func_56:   CSUB headRotateMotorTOerr
           JA   BACK_GROUND_PROCESS
func_58:   CSUB homeHeadRotateMotor
           JA   BACK_GROUND_PROCESS

// for FUNC_6  (INIT_DRAW_DOSE)

func_60:   CSUB checkCapSensor
           JA   BACK_GROUND_PROCESS
func_62:   CSUB checkNoSyringe
           JA   BACK_GROUND_PROCESS
func_64:   CSUB movePlungerToPrefill
           JA   BACK_GROUND_PROCESS
func_66:   CSUB checkSyrPoppedOut
           JA   BACK_GROUND_PROCESS
func_68:   CSUB checkPigPoppedOut
           JA   BACK_GROUND_PROCESS

// for FUNC_8   (DRAW_DOSE)

func_70:   CSUB addBacklashPrefill
           JA   BACK_GROUND_PROCESS
func_72:   CSUB startPullAir70
           JA   BACK_GROUND_PROCESS
func_74:   CSUB decapSyringe
           JA   BACK_GROUND_PROCESS
func_76:   CSUB moveBelowVial
           JA   BACK_GROUND_PROCESS
func_78:   CSUB insertNeedle
           JA   BACK_GROUND_PROCESS
func_80:   CSUB push70air
           JA   BACK_GROUND_PROCESS
func_82:   CSUB drawVial
           JA   BACK_GROUND_PROCESS
func_84:   CSUB ClearRunningErrors
           JA   BACK_GROUND_PROCESS
func_86:   CSUB moveSlowlyBottom
           JA   BACK_GROUND_PROCESS
func_88:   CSUB bumpPlunger
           JA   BACK_GROUND_PROCESS
func_90:   CSUB recapSyringe
           JA   BACK_GROUND_PROCESS
func_92:   CSUB insertIntoDozeCalib
           JA   BACK_GROUND_PROCESS
func_94:   CSUB openVialCover
           JA   BACK_GROUND_PROCESS
func_96:   CSUB closeVialCover
           JA   BACK_GROUND_PROCESS
func_98:   CSUB startPullAir70
           JA   BACK_GROUND_PROCESS
func_100:  CSUB drawVialMoreBack
           JA   BACK_GROUND_PROCESS
func_102:  CSUB homeVerticalMotor
           JA   BACK_GROUND_PROCESS
func_104:  CSUB homePistonMotor
           JA   BACK_GROUND_PROCESS
func_106:  CSUB setCenterOfSeptum
           JA   BACK_GROUND_PROCESS
func_108:  CSUB findCenterCapHolderManual
           JA   BACK_GROUND_PROCESS

// for FUNC_10   (CHECK_DONE)

func_110:  CSUB putSyringeInPig
           JA   BACK_GROUND_PROCESS
func_112:  CSUB incrementCycles
           JA   BACK_GROUND_PROCESS

// more functions

func_114:  CSUB homeVerticalMotorBoth
           JA   BACK_GROUND_PROCESS
func_116:  CSUB checkVialPoppedOut
           JA   BACK_GROUND_PROCESS
func_118:  CSUB getRandom
           JA   BACK_GROUND_PROCESS
func_120:  CSUB homePigHolderMotor
           JA   BACK_GROUND_PROCESS
func_122:  CSUB homeCapHolderMotor
           JA   BACK_GROUND_PROCESS
func_124:  CSUB startHomePistonMotor
           JA   BACK_GROUND_PROCESS
func_126:  CSUB armIntoDoseCalibrator
           JA   BACK_GROUND_PROCESS
func_128:  CSUB waitHomePistonMotor
           JA   BACK_GROUND_PROCESS
func_130:  CSUB findCapHolderAtNeedle
           JA   BACK_GROUND_PROCESS
func_132:  CSUB BubblesVibrateSyringe
           JA   BACK_GROUND_PROCESS

// manual movements functions

func_134:  CSUB retreatFromVial
           JA   BACK_GROUND_PROCESS
func_136:  CSUB VerticalManual
           JA   BACK_GROUND_PROCESS
func_138:  CSUB PigHolderManual
           JA   BACK_GROUND_PROCESS
func_140:  CSUB CapHolderManual
           JA   BACK_GROUND_PROCESS
func_142:  CSUB PistonManual
           JA   BACK_GROUND_PROCESS
func_144:  CSUB RotationManual
           JA   BACK_GROUND_PROCESS
func_146:  CSUB DoseCalibratorCheck
           JA   BACK_GROUND_PROCESS
func_148:  CSUB capVibrate
           JA   BACK_GROUND_PROCESS
func_150:  CSUB ExtractFromDoseCalibrator
           JA   BACK_GROUND_PROCESS
func_152:  CSUB dummy_sub
           JA   BACK_GROUND_PROCESS


//*****************************
    STOP     // just in case
//*****************************

//*******************************
//*******************************
// The subroutines start here  **
//*******************************
//*******************************

dummy_sub:                  // for dummy subroutines
   RSUB

//******************************************
// run this whenever no function is running
// this will enable the interrupts
//******************************************

BACK_GROUND_PROCESS:
    JA      BACK_GROUND_PROCESS
   
//**********************************
// Name: FIRST_RUN 
//
// Summary: first run after power up
//**********************************
FIRST_RUN:
    SGP     GB_ShowOveride, GPbank_2, clr           // in the show it must be set after each power ON
    CSUB    initInterrups
    GGP     GB_CenterOfVial, GPbank_2
    CALC    MUL, AVERAGE_CENTER_VIAL_WEIGHT         // for running average of center of vial
    AGP     GB_MulCenterOfVial, GPbank_2
    CSUB    initGB
    CSUB    CLEAR_ALL_ERRORS                           
    RSUB

//**********************************
initGB:
    SGP     GB_currentVersion, GPbank_2, CURRENT_VERSION     // Write version number
    STGP    GB_currentVersion, GPbank_2                      // Write version number
    SGP     GB_RS485BaudRate, GPbank_0, baud_rate_57600      // Set baudrate to 57600
    SGP     GB_CoordinateStorage, GPbank_0, 0                // 0=RAM only; 1=always also in EEPROM
    SGP     GB_DoNotRestoreUserVars, GPbank_0, 0             // 0=restore;  1=Do not restore at startup

    RSUB

//**********************************
// Name: INIT 
//
// Summary: Performs initialization
//**********************************
INIT:       // Init user variables
    SGP     GB_InitDone, GPbank_2, clr
    CSUB    LEDS_OFF
    SIO     Out_ShieldVail, OutBank_2, clr
    CSUB    initSyringes
    CSUB    initNeedles
    CSUB    initVerticalMotor
    CSUB    initPigHolderMotor
    CSUB    initCapHolderMotor
    CSUB    initPistonMotor
    CSUB    initHeadRotateMotor
    CSUB    initNotUsedMotor
    CSUB    initInterrups
    SGP     GB_HomingDone, GPbank_2, clr
    SGP     GB_InitDone, GPbank_2, set                       // init done
    RSUB

//**********************************

GREEN_ON:
    SIO     Out_RedLED, OutBank_2, LED_OFF                   // turn off red led
    SIO     Out_GreenLED, OutBank_2, LED_ON                  // turn on green led
    RSUB

RED_ON:
    SIO     Out_RedLED, OutBank_2, LED_ON                    // turn on red led
    SIO     Out_GreenLED, OutBank_2, LED_OFF                 // turn off green led
    RSUB

YELLOW_ON:
    SIO     Out_RedLED, OutBank_2, LED_ON                     // turn on red led
    SIO     Out_GreenLED, OutBank_2, LED_ON                   // turn on green led
    RSUB

LEDS_OFF:
    SIO     Out_RedLED, OutBank_2, LED_OFF                    // turn off red led
    SIO     Out_GreenLED, OutBank_2, LED_OFF                  // turn off green led
    RSUB

//**********************************

// Init syringes for their parameters
initSyringes:
 // bubbles
syringe1:
    GGP     GB_Syringe_Type, GPbank_2
    COMP    BD_syringe                                           // is it BD_syringe?
    JC      NE, syringe2                                         // no, try next
    SGP     GB_Max_Volume_current, GPbank_2, Max_Volume_1
    SGP     GB_microL_per_100mm_current, GPbank_2, microL_per_100mm_1
    SGP     GB_Syring_Length_current, GPbank_2, Syring_Length_1
    SGP     GB_Limit_for_Prefill_current, GPbank_2, Limit_for_Prefill_1
//    SGP     GB_LoadingDistance_current, GPbank_2, LoadingDistance_1
    JA      returnInitSyringes
syringe2:
    GGP     GB_Syringe_Type, GPbank_2
    COMP    HenryShine_syringe                         // is it HenryShine_syringe?
    JC      NE, syringe3                               // no, try next
    SGP     GB_Max_Volume_current, GPbank_2, Max_Volume_2
    SGP     GB_microL_per_100mm_current, GPbank_2, microL_per_100mm_2
    SGP     GB_Syring_Length_current, GPbank_2, Syring_Length_2
    SGP     GB_Limit_for_Prefill_current, GPbank_2, Limit_for_Prefill_2
//    SGP     GB_LoadingDistance_current, GPbank_2, LoadingDistance_2
    JA      returnInitSyringes
syringe3:
    GGP     GB_Syringe_Type, GPbank_2
    COMP    DPS_syringe                                 // is it DPS_syringe?
    JC      NE, syringe4                                // no, try next
    SGP     GB_Max_Volume_current, GPbank_2, Max_Volume_3
    SGP     GB_microL_per_100mm_current, GPbank_2, microL_per_100mm_3
    SGP     GB_Syring_Length_current, GPbank_2, Syring_Length_3
    SGP     GB_Limit_for_Prefill_current, GPbank_2, Limit_for_Prefill_3
//    SGP     GB_LoadingDistance_current, GPbank_2, LoadingDistance_3
    JA      returnInitSyringes
syringe4:
    GGP     GB_Syringe_Type, GPbank_2
    COMP    Terumo_2_5ml_syringe                        // is it Terumo_2_5ml_syringe?
    JC      NE, syringe5                                // no, try next
    SGP     GB_Max_Volume_current, GPbank_2, Max_Volume_4
    SGP     GB_microL_per_100mm_current, GPbank_2, microL_per_100mm_4
    SGP     GB_Syring_Length_current, GPbank_2, Syring_Length_4
    SGP     GB_Limit_for_Prefill_current, GPbank_2, Limit_for_Prefill_4
//    SGP     GB_LoadingDistance_current, GPbank_2, LoadingDistance_4
    JA      returnInitSyringes
syringe5:
    GGP     GB_Syringe_Type, GPbank_2
    COMP    Terumo_6ml_syringe                          // is it Terumo_6ml_syringe?
    JC      NE, syringe6                                // no, try next
    SGP     GB_Max_Volume_current, GPbank_2, Max_Volume_5
    SGP     GB_microL_per_100mm_current, GPbank_2, microL_per_100mm_5
    SGP     GB_Syring_Length_current, GPbank_2, Syring_Length_5
    SGP     GB_Limit_for_Prefill_current, GPbank_2, Limit_for_Prefill_5
//    SGP     GB_LoadingDistance_current, GPbank_2, LoadingDistance_5
    JA      returnInitSyringes
syringe6:
    GGP     GB_Syringe_Type, GPbank_2
    COMP    BD_2ml_syringe                              // is it BD_2ml_syringe?
    JC      NE, syringe7                                // no, try next
    SGP     GB_Max_Volume_current, GPbank_2, Max_Volume_6
    SGP     GB_microL_per_100mm_current, GPbank_2, microL_per_100mm_6
    SGP     GB_Syring_Length_current, GPbank_2, Syring_Length_6
    SGP     GB_Limit_for_Prefill_current, GPbank_2, Limit_for_Prefill_6
//    SGP     GB_LoadingDistance_current, GPbank_2, LoadingDistance_6
    JA      returnInitSyringes
syringe7:
    GGP     GB_Syringe_Type, GPbank_2
    COMP    Other_7                                      // is it Other_7?
    JC      NE, defaultSyringe                                  // no, exit
    SGP     GB_Max_Volume_current, GPbank_2, Max_Volume_7
    SGP     GB_microL_per_100mm_current, GPbank_2, microL_per_100mm_7
    SGP     GB_Syring_Length_current, GPbank_2, Syring_Length_7
    SGP     GB_Limit_for_Prefill_current, GPbank_2, Limit_for_Prefill_7
//    SGP     GB_LoadingDistance_current, GPbank_2, LoadingDistance_7
    JA      returnInitSyringes

defaultSyringe:  // Henry Shine
    SGP     GB_Syringe_Type, GPbank_2, DEFAULT_SYRINGE_TYPE     // HenryShine_syringe
    JA      initSyringes

returnInitSyringes:    // save in EEPROM


    GGP     GB_preFillRequest, GPbank_2                                     // check for requested operation: "more"?
    COMP    PRE_FILL_REQUEST                                                // yes? then no "more"
    JC      EQ, justLoadMaxVol                                              // if yes, continue
    GGP     GB_adjustCycle, GPbank_2                                        // check for requested operation: "more"?
    COMP    ADJUST_STATE                                                    // adjust? do not "more"
    JC      EQ, justLoadMaxVol                                              // if yes, do not "more"
//****
    CALC    LOAD, PISTON_MORE_uL                   // u Litter
    CALCVA  SUB, GB_Max_Volume_current
//****
justLoadMaxVol:
    RSUB

//**********************************

initNeedles:

 // default for 25 mm and Gauge 22: DEF_DRAW_WAIT_TIME
 // The flow with same presure relates to the 1/length and internal dia^2

// check needle length
    GGP     GB_NeedleLength, GPbank_2                      // get needle Length
    COMP    0                                              // length assigned?
    JC      GT, calcNeedle
    SGP     GB_NeedleLength, GPbank_2, DEFAULT_NEEDLE_LENGTH  // no, assign default

calcNeedle:
 // calculate length, compare to 25 mm
    SGP     GB_DrawWaitTime, GPbank_2, DEF_DRAW_WAIT_TIME  // init initially to 2 seconds, needs to
                                                           // calculate in INIT according to needle length and gauge
    GGP     GB_NeedleLength, GPbank_2                      // get needle Length
    CALCX   LOAD                                           // move to X
    GGP     GB_DrawWaitTime, GPbank_2                      // load default draw time
    CALCX   MUL                                            // multiply by needle length in X
    CALC    DIV, DEFAULT_NEEDLE_LENGTH                     // divide by default length (25)
    AGP     GB_DrawWaitTime, GPbank_2                      // now in GP according to needle length

// ///////////////////////////////////////
//
// calculate dwell time of gauge				
// 				
// 		dwell time of 22		2.000
// 				
// Gauge inner  relative   relative  multiply    dwell 
//       dia    to 22      square                time
// 				
// 20    0.603  1.460      2.132      46.9       0.938
// 20    0.514  1.245      1.549      64.6       1.291
// 22    0.413  1.000      1.000     100         2.000
// 23    0.337  0.816      0.666     150.2       3.004
// 24    0.311  0.753      0.567     176.4       3.527
//
// ///////////////////////////////////////
    
 // check Gauge, compare 22
    GGP     GB_needleGauge, GPbank_2                       //  current default needle Gauge
    COMP    22
    JC      EQ, adjustDrawVolume

 // check Gauge, compare 20
    GGP     GB_needleGauge, GPbank_2                       //  current default needle Gauge
    COMP    20
    JC      NE, compare21
    GGP     GB_DrawWaitTime, GPbank_2                      // load default draw time
    CALC    MUL, 47                                        // 0.94 s
    CALC    DIV, 100
    AGP     GB_DrawWaitTime, GPbank_2                      // now in GP
    JA      adjustDrawVolume

compare21:
 // check Gauge, compare 21
    GGP     GB_needleGauge, GPbank_2                       //  current default needle Gauge
    COMP    21
    JC      NE, compare23
    GGP     GB_DrawWaitTime, GPbank_2                      // load default draw time
    CALC    MUL, 64                                        // 1.29 s
    CALC    DIV, 100
    AGP     GB_DrawWaitTime, GPbank_2                      // now in GP
    JA      adjustDrawVolume

 // check Gauge, compare 23
compare23:
    GGP     GB_needleGauge, GPbank_2                       //  current default needle Gauge
    COMP    23
    JC      NE, compare24
    GGP     GB_DrawWaitTime, GPbank_2                      // load default draw time
    CALC    MUL, 150                                       // 3.0 s
    CALC    DIV, 100
    AGP     GB_DrawWaitTime, GPbank_2                      // now in GP
    JA      adjustDrawVolume

 // check Gauge, compare 24
compare24:
    GGP     GB_needleGauge, GPbank_2                       //  current default needle Gauge
    COMP    24
    JC      NE, adjustDrawVolume
    GGP     GB_DrawWaitTime, GPbank_2                      // load default draw time
    CALC    MUL, 176                                       // 3.5 s
    CALC    DIV, 100
    AGP     GB_DrawWaitTime, GPbank_2                      // now in GP

adjustDrawVolume:
    GGP     GB_microLtoWithdraw, GPbank_2                  // load draw volume
    COMP    0
    JC      LE, returnAdjustDrawVolume                     // If negative draw, do not multiply by negative
    GGP     GB_DrawWaitTime, GPbank_2                      // load calculated so far draw time
    CALCX   LOAD                                           // draw time into X
    GGP     GB_microLtoWithdraw, GPbank_2                  // load the withdraw volume [uL] into A
    COMP    MIN_DRAW_PISTON_uL                             // because always we draw first the "1ml", so the time till that will be for 1ml
    JC      LE, calcLessThanOneMl
    GGP     GB_microLtoWithdraw, GPbank_2                  // load the withdraw volume [uL] into A - again just in case
    JA      calcAdjustDrawVolume
calcLessThanOneMl:
    CALC    LOAD, MIN_DRAW_PISTON_uL                       // load the withdraw volume [uL] of 1 mlinto A
calcAdjustDrawVolume:
    CALCX   MUL
    CALC    DIV, DEFAULT_DRAW_VOLUME                       // adjust according to draw volume
    AGP     GB_DrawWaitTime, GPbank_2                      // now in GP
returnAdjustDrawVolume:
    RSUB

//**********************************

// Init M_verticalMotor axis  (M_0)
    //  ref left  = "  UP" sensor
    //  ref right = "Down" sensor

initVerticalMotor:
    MST     M_verticalMotor                                             // Motor stop
    SAP     AP_RefSearchSpeed, M_verticalMotor, SEARCH_SPEED_VERT       // speed for search
    SAP     AP_RefSwitchSpeed, M_verticalMotor, SWITCH_SPEED_VERT       // speed for final search
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_ROT // Set maximum positioning speed
    SAP     AP_MaxAcceleration, M_verticalMotor, ACC_VERT               // Set maximum acceleration
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT            // Set absolute max. current
    SAP     AP_StandbyCurrent, M_verticalMotor, STBY_CURRENT_VERT       // Set standby current (the current limit two seconds after the motor has stopped)
    SAP     AP_BoostCurrent, M_verticalMotor, 255                       // while acceleration of decelaration
    SAP     AP_RightLimitSwitchDisable, M_verticalMotor, clr            // Enable right limit switch
    SAP     AP_LeftLimitSwitchDisable, M_verticalMotor, clr             // Enable left limit switch
    SAP     AP_MicrostepResolution, M_verticalMotor, microsteps_16      // Set microstep resolution to 16 microsteps
    SAP     AP_StepInterpolEnable, M_verticalMotor, set                 // on 16 microsteps only
    SAP     AP_RampDivisor, M_verticalMotor, 3                          // Set ramp divisor
    SAP     AP_PulseDivisor, M_verticalMotor, 3                   		// Set pulse divisor
    SAP     AP_SoftStopFlag, M_verticalMotor, set                       // Soft stop (using deceleration ramp) when a stop switch is hit
    SIO     MotorUpRelease, OutBank_2, set                              // un short and relesae the motor coils

//GB_needleLengthInMicroSteps = 130                                     // verticalMicroStepsPerMM * GB_needleLength
    GGP     GB_needleLength, GPbank_2                                   // A = GB_needleLength
    CALC    MUL, verticalMicroStepsPerMM                                // A = verticalMicroStepsPerMM * GB_needleLength
    AGP     GB_needleLengthInMicroSteps, GPbank_2                       // load to parameter 

//GB_defaultNeedleLengthInMicroSteps = 132
    CALC    LOAD, DEFAULT_NEEDLE_LENGTH                                 // A = default 25 needle length (25)
    CALC    MUL, verticalMicroStepsPerMM                                // A = verticalMicroStepsPerMM * DEFAULT_NEEDLE_LENGTH
    AGP     GB_defaultNeedleLengthInMicroSteps, GPbank_2                // load to parameter 

//    SCO     BELOW_VIAL_COORD, M_verticalMotor, VERTICAL_FOR_ROTATION    // set coordinate for interpolation
    CALC    LOAD, VERTICAL_FOR_ROTATION                                 // load  to A
    ACO     BELOW_VIAL_COORD, M_verticalMotor                           // set coordinate for interpolation

    GGP     GB_VerticalHomePos, GPbank_2                                // load  to A
    ACO     ABOVE_CAP_COORD, M_verticalMotor                            // set coordinate for interpolation
    RSUB
    
// Init M_pigHolderMotor axis  (M-1)
    //  ref left  = "pig Holder is out" sensor
    //  ref right = "pig holder is  in" sensor (under needle)

initPigHolderMotor:
    MST     M_pigHolderMotor                                        // Motor stop
    SAP     AP_RefSearchSpeed, M_pigHolderMotor, SEARCH_SPEED_PIG   // speed for search
    SAP     AP_RefSwitchSpeed, M_pigHolderMotor, SWITCH_SPEED_PIG   // speed for final search
    SAP     AP_MaxPositioningSpeed, M_pigHolderMotor, MAX_POS_SPEED_PIG // Set maximum positioning speed
    SAP     AP_MaxAcceleration, M_pigHolderMotor, ACC_PIG           // Set maximum acceleration
    SAP     AP_MaxCurrent, M_pigHolderMotor, MAX_CURRENT_PIG        // Set absolute max. current
    SAP     AP_StandbyCurrent, M_pigHolderMotor, STBY_CURRENT_PIG   // Set standby current (the current limit two seconds after the motor has stopped)
    SAP     AP_BoostCurrent, M_pigHolderMotor, 255                  // while acceleration of decelaration
    SAP     AP_RightLimitSwitchDisable, M_pigHolderMotor, set       // Disable right limit switch
    SAP     AP_LeftLimitSwitchDisable, M_pigHolderMotor, clr        // Enable left limit switch
    SAP     AP_MicrostepResolution, M_pigHolderMotor, microsteps_16 // Set microstep resolution to 16 microsteps
    SAP     AP_StepInterpolEnable, M_pigHolderMotor, set            // on 16 microsteps only
    SAP     AP_RampDivisor, M_pigHolderMotor, 3                     // Set ramp divisor
    SAP     AP_PulseDivisor, M_pigHolderMotor, 3                    // Set pulse divisor
    RSUB

// Init M_capHolderMotor axis (M_2)
    //  ref left  = "cap Holder is out" sensor
    //  ref right = "cap holder is  in" sensor

initCapHolderMotor:
    SGP     GB_capMicroStepsPerMM, GPbank_2, capMicroStepsPerMM   // just to see on line
    SGP     GB_limitCapBentMicroS, GPbank_2, limitCapBentMicroS   // just to see on line
    MST     M_capHolderMotor                                        // Motor stop
    SAP     AP_RefSearchSpeed, M_capHolderMotor, SEARCH_SPEED_CAP   // speed for search
    SAP     AP_RefSwitchSpeed, M_capHolderMotor, SWITCH_SPEED_CAP   // speed for final search
    SAP     AP_MaxPositioningSpeed, M_capHolderMotor, MAX_POS_SPEED_CAP // Set maximum positioning speed
    SAP     AP_MaxAcceleration, M_capHolderMotor, ACC_CAP           // Set maximum acceleration
    SAP     AP_MaxCurrent, M_capHolderMotor, MAX_CURRENT_CAP        // Set absolute max. current
    SAP     AP_StandbyCurrent, M_capHolderMotor, STBY_CUR_CAP       // Set standby current (the current limit two seconds after the motor has stopped)
    SAP     AP_BoostCurrent, M_capHolderMotor, 255                  // while acceleration of decelaration
    SAP     AP_RightLimitSwitchDisable, M_capHolderMotor, set       // disable right limit switch for REF
    SAP     AP_LeftLimitSwitchDisable, M_capHolderMotor, clr        // Enable left limit switch
    SAP     AP_MicrostepResolution, M_capHolderMotor, microsteps_16 // Set microstep resolution to 16 microsteps
    SAP     AP_StepInterpolEnable, M_capHolderMotor, set            // on 16 microsteps only
    SAP     AP_RampDivisor, M_capHolderMotor, 3                     // Set ramp divisor
    SAP     AP_PulseDivisor, M_capHolderMotor, 3                    // Set pulse divisor
    RSUB

// Init M_pistonMotor axis  (M_3)
    //  ref left  = "piston empty" sensor
    //  ref right = "piston  full"  sensor

initPistonMotor:
//  SGP     GB_EndSwitchPlarity, GPbank_0, reversePolarity3to5    // set in motor 5. reverse polarity for motors 3-5
    MST     M_pistonMotor                                         // Motor stop
    SAP     AP_RefSearchSpeed, M_pistonMotor, SEARCH_SPEED_PIST   // speed for search
    SAP     AP_RefSwitchSpeed, M_pistonMotor, SWITCH_SPEED_PIST   // speed for final search
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST  // Set maximum positioning speed
    SAP     AP_MaxAcceleration, M_pistonMotor,  ACC_PIST          // Set maximum acceleration
    SAP     AP_MaxCurrent, M_pistonMotor, MAX_CURRENT_PIST        // Set absolute max. current
    SAP     AP_StandbyCurrent, M_pistonMotor, STBY_CURRENT_PIST   // Set standby current (the current limit two seconds after the motor has stopped)
    SAP     AP_BoostCurrent, M_pistonMotor, 255                   // while acceleration of decelaration
    SAP     AP_RightLimitSwitchDisable, M_pistonMotor,  clr       // Enable right limit switch
    SAP     AP_LeftLimitSwitchDisable, M_pistonMotor,  clr        // Enable left limit switch
    SAP     AP_MicrostepResolution, M_pistonMotor, microsteps_16  // Set microstep resolution to 16 microsteps
    SAP     AP_StepInterpolEnable, M_pistonMotor, set             // on 16 microsteps only
    SAP     AP_RampDivisor, M_pistonMotor, 3                      // Set ramp divisor
    SAP     AP_PulseDivisor, M_pistonMotor, 3                     // Set pulse divisor
// calculate:  GB_pistonMicroStepPer100microL                     // 
    GGP     GB_microL_per_100mm_current, GPbank_2                 // A = GB_microL_per_100mm_current
    CALCX   SWAP                                                  // X = GB_microL_per_100mm_current
    CALC    LOAD, 10000                                           // 100 --> A
    CALC    MUL, pistonMicroStepsPerMM                            // A = 10000 * pistonMicroStepsPerMM
    CALCX   DIV                                                   // A = A / X
    AGP     GB_pistonMicroStepPer100MicroL, GPbank_2              // load to parameter 
    RSUB

// Init M_headRotateMotor axis (M_4)
// ref left  = "head syringe left" sensor

initHeadRotateMotor:
    SGP     GB_EndSwitchPlarity, GPbank_0, reversePolarity3to5       // set in motor 5. reverse polarity for motors 3-5
    SGP     GB_rotateMicroStepsPerMM, GPbank_2, rotateMicroStepsPerMM   // just to see on line
    SGP     GB_limitNeedleBentMicroS, GPbank_2, limitNeedleBentMicroS   // just to see on line
    MST     M_headRotateMotor                                        // Motor stop
    SAP     AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT   // speed for search
    SAP     AP_RefSwitchSpeed, M_headRotateMotor, SWITCH_SPEED_ROT   // speed for final search
    SAP     AP_MaxPositioningSpeed, M_headRotateMotor, MAX_POS_SPEED_VER_ROT // Set maximum positioning speed
    SAP     AP_MaxAcceleration, M_headRotateMotor,  ACC_ROT          // Set maximum acceleration
    SAP     AP_MaxCurrent, M_headRotateMotor, MAX_CURRENT_ROT        // Set absolute max. current
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE    // Set standby current (the current limit two seconds after the motor has stopped)
    SAP     AP_BoostCurrent, M_headRotateMotor, 255                  // while acceleration of decelaration
    SAP     AP_RightLimitSwitchDisable, M_headRotateMotor, set       // Disable right limit switch
    SAP     AP_LeftLimitSwitchDisable, M_headRotateMotor, set        // Enable left limit switch
    SAP     AP_MicrostepResolution, M_headRotateMotor, microsteps_16 // Set microstep resolution to 16 microsteps
    SAP     AP_StepInterpolEnable, M_headRotateMotor, set            // on 16 microsteps only
    SAP     AP_RampDivisor, M_headRotateMotor, 3                     // Set ramp divisor
    SAP     AP_PulseDivisor, M_headRotateMotor, 3                    // Set pulse divisor
    SCO     BELOW_VIAL_COORD, M_headRotateMotor, HEAD_ROTATE_NEEDLE_SEARCH // set coordinate for interpolation
    SCO     ABOVE_CAP_COORD, M_headRotateMotor, NEEDLE_TO_HOME       // set coordinate for interpolation
    RSUB

// Init M_notUsedMotor axis (M_5)
// ref right  = "dose calibrator dipper" anti crash sensor
// ref left   = "syringe popped out" sensor

initNotUsedMotor:
    SGP     GB_EndSwitchPlarity, GPbank_0, reversePolarity3to5       // set in motor 5. reverse polarity for motors 3-5
    SAP     AP_RightLimitSwitchDisable, M_headRotateMotor, clr       // Disable right limit switch
    SAP     AP_LeftLimitSwitchDisable, M_headRotateMotor, set        // Enable left limit switch
    RSUB

//******************************************
//
// stop all motors and return
// - stop program at the calling function
//
//******************************************

ABORT:
    SGP     GB_CurrentState, GPbank_2, ABORTED
    STGP    GB_CurrentState, GPbank_2
    GGP     GB_errors_Ver002, GPbank_2                  // load  error word
    CALC    OR, BitEr_machineAborted                    // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it

ABORT_NoReport:
    SAP     AP_MaxAcceleration, M_verticalMotor, ACC_VERT_HIGH     // stop quicker
    MST     M_verticalMotor                             // Stop up down
    MST     M_pigHolderMotor                            // Stop rotate head
    MST     M_capHolderMotor                            // Stop hold syringe
    MST     M_pistonMotor                               // Stop fill syringe
    MST     M_headRotateMotor                           // Stop move pig
    SGP     GB_MotorIsMoving, GPbank_2, clr             
    CSUB    RED_ON                                      // red LED
//  DI      TI_INPUT2                                   //  hands in machine
    DI      TI_STOPLEFT5                                //  syringe pop out interrupt
    DI      TI_STOPRIGHT5                               //  dipper interrupt
    WAIT    TICKS, 0, 100                                                // wait one second for all the motors to stop
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_LOW    // Set standby current low to enable moving the rotation down
    SAP     AP_MaxAcceleration, M_verticalMotor, ACC_VERT                // Set maximum acceleration
    RST     BACK_GROUND_PROCESS                         // Stop a running TMCL program. Reset program counter and stack pointer 

//************************************
//
// Interupt definition for read handI
//
//************************************

initInterrups:

//    VECT   TI_TIMER0, Timer0Irq
//    SGP    TI_TIMER0, GPbank_3, 100            // to calculate time 100 MS 0.1 sec
//    DI     TI_TIMER0  

// Interrupt vector definition
 // for curtain of hands in
 //   VECT    TI_INPUT2, Input2Irq                    // Define the interrupt vector
 //   SGP     TI_INPUT2, GPbank_3, low_high           // Setup off to on
 //   EI      TI_INPUT2                               // Enable this interrupt

 // for pig was replaced
    VECT    TI_INPUT7, Input7Irq
    SGP     TI_INPUT7, GPbank_3, both                 // 
    EI      TI_INPUT7                                 // Enable this interrupt

 // for moved up from dose calibrator
    VECT    TI_STOPLEFT4, StopLeft4Irq                // left rotate ref touched
    SGP     TI_STOPLEFT4, GPbank_3, both              // 
 //   EI      TI_STOPLEFT4                            // Will be enabled on init / draw_doze

 // for syringe popped out
    VECT    TI_STOPLEFT5, StopLeft5Irq                // syringe poppes out
    SGP     TI_STOPLEFT5, GPbank_3, high_low          // high to low
 //   EI      TI_STOPLEFT5                            // Will be enabled on init / draw_doze

 // for head touches dose calibrator's dipper
    VECT    TI_STOPRIGHT5, StopRight5Irq              // connected to ref right of unused motor 5
    SGP     TI_STOPRIGHT5, GPbank_3, low_high         // syringe poppes out
 //   EI      TI_STOPRIGHT5                           // Will be enabled on draw_doze

 // enable global
    EI      TI_GLOBAL  
    RSUB

//*******************************************
// Name: Input2Irq
//
// Summary:  Timer 0 will calculate the elapsed time of Draw
//
//*******************************************

//Timer0Irq:   // calculate draw time
//    GGP     GB_drawCycleTime, GPbank_2                  // get interrupt counter
//    CALC    ADD, 1                                      // add 1 to accumulator
//    AGP     GB_drawCycleTime, GPbank_2                  // A to Global parameter
//    RETI

//*******************************************************
// Name: Pig was replaced
//
// Summary:  When PIG is touches, set GB_PigWasReplaced
//
//*******************************************************

Input7Irq:
    SGP     GB_PigWasReplaced, GPbank_2, set            // signal error: pig replaced
    CSUB    incrementInterruptsCount
    RETI

//*******************************************************************
// Name: going from dose calibrator to rotate sensor
//
// Summary:  This will be the signal to continue running the program
//
//*******************************************************************

StopLeft4Irq:
    SGP     GB_TouchedLeftRef, GPbank_2, set            // signal error: pig replaced
    CSUB    incrementInterruptsCount
    RETI

//*****************************
// Name: syringe popped off
//
//*****************************

StopLeft5Irq:
    CSUB    incrementInterruptsCount

    GGP     GB_inHomeCapHolderMotor, GPbank_2           // check if retry checking 3 times
    COMP    IN_HOME_CAP_HOLDER_MOTOR
    JC      NE, notInHomeCapHolder
    MST     M_capHolderMotor                            // Stop hold syringe
    RFS     STOP, M_capHolderMotor                      // Stop reference search
    WAIT    RFS, M_capHolderMotor, WAIT_TICKS_SHORT     // wait till stops or 2 seconds
    CSUB    checkSyrPoppedOut3Times                     // check again and again, if still off, will ABORT there
    CSUB    homeCapHolderMotor
    JA      retiLeft5                                   // If there was an error in would call ABORT from checkSyrPoppedOut3Times

notInHomeCapHolder:
    CSUB    checkSyrPoppedOut3Times                     // check again and again, if still off, will ABORT there
retiLeft5:
    RETI

//*******************************************
// Name: head touches dose calibrator's tool
//
//*******************************************

StopRight5Irq:
    CSUB    incrementInterruptsCount

    GGP     GB_InDoseCalibrator, GPbank_2               // max depth into A
    CALC    SUB, STOP_CHECK_DIPPER_VERTICAL             // do not check below
    CALCX   LOAD                                        // start ABORT into X
    GAP     AP_ActualPosition, M_verticalMotor          // current hight in A
    CALCX   SUB
    COMP    0
    JC      GT, returnStopRight5Irq                     // if dipper don't abort
 // error occured:
    GAP     AP_ActualPosition, M_verticalMotor          // current hight in A
    AGP     GB_dipperInterruptHight, GPbank_2
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_doseCalibDipper                   // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setAnyError
    CSUB    ABORT
returnStopRight5Irq:
    RETI

//*******************************************
incrementInterruptsCount:
    GGP     GB_InterruptCount, GPbank_2                 // get interrupt counter
    CALC    ADD, 1                                      // add 1 to accumulator
    AGP     GB_InterruptCount, GPbank_2                 // A to Global parameter
    RSUB
//*******************************************


