//****************************************
// Name:        UniDoze_SW.tmc
//
// Description: UniDoze software
//
//***********************************************************************************************************
// Changes: V2018-01-22 - initial code
//          V2018-07-05 - after Philadelphia show
//           1. review production: V=ok  G=move to global var
//           2. remove PIG types
//           3. remove BACK_PREFILL
//           4. Manual movements
//           5. 9 global parameters for calibration
//           6. functions for coord movents, wait moves (+long +rfs)
//           7. Parameters removed, new functions
//           8. Clear dose calibrator
//           9. Prefill volume check
//          10. Pig replaced
//          11. curtain
//          12. syringe exists?
//          13. Pig exists?
//          14. Adjust end of rotation before rfs needle
//          15. Move pig fast and high current at end
//          16. moving average for center of vial. not enabled
//          17. CopyToTemporaryGP, RestoreTemporaryGP
//          18. Needle size and length
//          19. Homeing func
//          20. Calibration support
//          21. Reset RST on v_1.45
//          22. parameter for dose calibrator depth
//          23. INIT runs on a new board
//          24. Enable curtain at initDraw, DrawDose, checkDone
//          25. increment draw cycles insteat of completed , acceleration of piston 10 -> 200
//          26. Report ABORT condition - state 90, set anyError, error 28 -> BitEr_machineAborted
//          27. default syringe
//          28. Enable full fill vial from prefill syringe
//          29. Manual move, one fun and clear GB_MotorIsMoving after Time Out
//          30. Standby current of cap holder changed from 150 to 200
//          31. After detection of syringe or vial pop out, ABORT
//          32. New version each release
//          33. interrupt for syringe pop off in DRAW_DOSE and CHECK_DONE
//          34. double click on DoseCalibratorCheck creates error but enables re-click
//          35. if syringe is bent more than 1.6 mm, do not draw, move to 90 degrees
//  End of V002
//  Not compatible:
//          36. V003001 sense needle to position cap holder
//          37. V003001 U7 senses the crash of dose calibrator in head board. interrupt.
//          38. V003002 check on DoseCalibratorCheck no syringe
//          39. V001003003 syringeIsIn at motor 5 REF
//          40. V001003004 research for needle at capHolder, if error, put in parameter position
//          41. V001003005 serial # of the machine, GB_RobotSerialNumber = 6
//              If the serial # is 001003005,
//              Machine 001= Unidose, HW version 003 = Sensor on cap holder,  Machine # = 005
//          42. move cap to position relative to GB_CapHoldsSyringe before RFS
//          43. V1030007 calibration function 108: findCapHolderAtNeedle
//          44. V1030008 added acceleration to cap holder, rfs starts 150
//          45. V1030009 Interuupts repaired
//          46. V1030010 DI on ABORT, vertical acc = 10,  vertical speed from calibrator = 800, while rotation = 1000
//          47. V1030011 moves from Dose calibrator via top ref switch, or when adjust, via home switch
//          48. V1030012 instead of #47, check tht at the end of movement, touched the left ref rotate sensor
//          49. V1030013 vertical speed from dose calibrator changed from 1200 to 1000
//          50. V1030014 VERTICAL_FOR_NEEDLE = 12075
//          51. V1030015 goto TAMPA Jan 10, 2019
//          52. V1030016
//          53. V1030017 removed hands detected
//          54. V1030018 needle in vial random +/- 0.8 [mm], removed initializeForTesting
//          55. V1030019 changed start of cap holder search fro 120 to 80
//          56. V1040020 cap holder sensor for needle position is off center. GB_NeedleAtCapOffset  = 55
//          57. V1040021 compatibility with machine 3005 (Tampa 2), not use of GB_55
//          58. V1040022 arm into the dose calibrator function 126, max dipper detection 4000
//          59. V1040023 PIG standby current 25 at power up
//          60. V1040024 fixed setCenterOfSeptum for starting operation
//          61. V1040025 Checks before "Fill Dose" that the dipper sensor if not blocked
//          62. V1040026 correct outbank_2 -> GPbank_2  sould not differ
//          63. V1040027 add error for cap bent needle         BitEr_needleBentCap = %1000000000 // bit 512
//          64. V1040028 RFS wait short for second rotation search
//          65. V1040029 Retry syringe pop out at the cap holder
//          66. V1040030 Retry syringe whithin interrupt routine
//          67. V1040031 No more error om bent needles below +/- 3.0 mm
//          68. V1040032 solve problem of cap holder touching rotating head on initialize by setting motor current to 0
//          69. V1040033 check cap sensor before initialize, so that the syringe holder is not there
//          70. V1040034 calculate decap height, relative to loading height
//          71. V1040035 top needle higher at sensor (12000), shorter timeout if miss
//          72. V1040036 longer timeout for rotation rfs 1s --> 2s
//          73. V1040037 variable for needle from bump GB to full entrance
//          74. V1040038 Added syringe #3: DPS
//          75. V1040039 GB_CoordinateStorage 0=RAM only, remove un-neccessaray STGP to save EEPROM
//          76. V1040040 moved init_GB to first run. 
//                       erase EEPROM of errors if "AnyError=1" at INIT_DRAW_DOSE, DRAW_DOSE, CHECK_DONE 
//          77. V1040041 move down for needle recapping
//          78. V1040042 Do not check for home limit sw after running home for PIG holder, goto home always
//          79. V1040043 added pulse divisor to vertical motor, needle hight relative to bump parameter
//          80. V1040044 vibrate rotate to relief bubbles, bump down to 0.04 mL
//          81. V1040045 add wetting of the syringe before drawing liquid
//          82. V1040046 Back to file UniDoze_Setup.tmc
//          83. V1040047 Back to simple wetting and vibrating
//          84. V1040048 corrected fast draw cycle to slow
//          85. V1040049 default kicks=0, repaired drawWaitTime
//          86. V1040050 added gauges 20, 24, draw at fast speed (800), Default draw wait = 100, random needle in vial +- 0.4mm
//          87. V1040051 for adjust cycle go up to absolute hight for short needle
//          88. V1040052 needle interrupt only, no more checkings, always 3 check before error, changed 2 "JC ZE" to "COMP + JC "
//                       function: "func_134:  CSUB retreatFromVial"  if stuck in vial
//                       removed restore and backup subroutines (148, 150)
//          89. V1040053 GP 26 holds the random movement in um. If <=0, sets to 0, 
//                       if >MAX_RANDOM_IN_VIAL sets to RANDOM_um_TO_MOVE_DEF
//          90. V1040054 GP 26 holds the random movement in um. If <=0, sets to 0, 
//                       Parameter for adjustment of hight for needle sensing
//          91. V1040055 Vibrate CAP holder while moving  the syringe into the cap
//          92. V1040056 V1040055 without cap vibration
//          93. V1040057 double the bump to 0.08 ml - canceled later
//          94. V1040058 "push more" piston before, slow draw, shorter wait, no needlee vibration, no bubbles removal, removed SN_003
//          95. V1040059 Try Again: push all previous draw before filling again
//          96. V1040060 quicker "pull more" at the end of draw cycle
//          97. V1040061 correct behaviour of retreat function
//          98. V1040062 squeeze the cap, check it did not fall
//          99. V1040063 when checking cap existance if no cap found, look for bend cap that eliminates insersion into PIG by RFS timeout
//         100. V1040064 when checking cap existance if no cap found, look for bend cap that eliminates insersion into PIG by 3+5 measurements
//         101. V1040065 adjust bubbles issues
//         102. V1040066 adjust bubbles issues - slow more before draw
//         103. V1040067 adjust bubbles issues - fast more before draw
//         104. V1040068 retreat always rotate
//         105. V1040069 initialize after no needle, enable to run initialize after initialize error, adjust for faster
//         106. V1040070 adjust bubbles
//         107. V1040071 repair volume calculation error
//         108. V1040072 draw slower 5mm (was 4), then draw/push slow after 1ml fast draw
//         109. V1040073 draw speed slowed from 1500 to 1200 PPS
//         110. V1040074 high pitch for the piston: 4.8768 mm
//         111. V1040075 high pitch for the piston: 4.8768 mm + fast more + alow more volume for prefill & adjust
//         112. V1040076 back to slow "more" at the start of draw, slower push (re-try), no squeezinng the piston, 3s -> 2s wait time, 
//                       wait time at least for 1 ml, repaired bug of not waiting after small dozes.
//         113. V1040077 check if the cap fell down 1mm above the squeeze cap hight. adjusted for taiwan
//         114. V1040079 check needle length for exit from cap. Adjusted for taiwan
//         115. V1040080 Add more syringes
//         116. V1040081
//         117. V1040082 check cap. more back speed according to gauge and length.
//         118. V1040083 moved position of pig holder out when squeezing cap after dose calibrator.
//         119. V1040084 FOR TAIWAN MACHINE. Syringe cap is transparent, will not detect. I the future willcompare syringe type.
//         120. V1040085 added BD 2ml syringe, with higher movement up afted de-capping. if Terumo 2.5ml, do not check fallen cap.
//         121. V1040086 set hight of needle at cap. adjusted by needle length parameter
//                       SGP     GB_syringeWOcapInPIG, GPbank_2, clr  at clear all errors
//         122. V1040087 removed STGP for GB_adjustmentsTotal
//         123. V1040088 Bump amount 46 -> 60 microL (BUMP_DOWN_REL_uL)
//         124. V1040089 cancel: Bump amount 60 -> 46 microL (BUMP_DOWN_REL_uL), 
//                       less currrent when moving into dose calibrator :150
//                       Added new function: func_150: ExtractFromDoseCalibrator  and error BitEr_stuckInDoseCalibrator
//                       The function will run only if lower than 20000
//         125. V1040089-a returned Bump amount 60 -> 46 microL (BUMP_DOWN_REL_uL)
//         126. V1040089-b made extract dipper work with UI
//         127. V1040089-c created tapTap to flick the syringe with the vial shield cover 
//         128. V1040090-c implementing adaptation to different needle length sizes
//         129. V1040091-c optimizing taptap timing
//         130. V1040092-c adding factor for adjusting volume
//         131. V1040093-c needle adaptation
//         132. V1040094-c insert needle adaptation
//         133. V1040095-c-China_patch cap_adaptation
//         134. V1040096-c-China_patch fixing squeeze
//         135. V1040097-c-China_patch SIZES ABCD 
//         136. V1040097-c-ISORAD patch
//
//***********************************************************************************************************

//************
// Includes
//************

#Include UniDoze_TMCLParam.tmc                         // TMCL Parameters
#Include UniDoze_Setup.tmc                             // UniDoze Parameters & initialization
// this file 2023-10-08-V40097-c-ISORAD_patch-UniDoze-SW.tmc

//*********************************
//*********************************
// Subroutines initialized from PC
//*********************************
//*********************************

//*******************************************
// Name: FIND_HOMES  
//
// Summary: Performs axis homeing
//*******************************************

FIND_HOMES:

    SGP     GB_HomingDone, GPbank_2, clr       // clear homing done  
    CSUB    checkNoSyringeFH                   // make sure no syringe is in
    GGP     GB_any_Error, GPbank_2             // get any error status
    COMP    ANY_ERROR_EXISTS                   // exists?
    JC      EQ, return_FIND_HOME               // yes, return 
    SAP     AP_MaxCurrent, M_headRotateMotor, 0    // Set absolute max. current
    CSUB    homePigHolderMotorBoth             // Pig and Cap holders first to clear the way for vertical
    CSUB    homeCapHolderMotor
    CSUB    HomeVerticalMotor                  // get it out of pig and cap
    CSUB    PositionHeadRotateMotor
    CSUB    homePigHolderMotorBoth             // Pig and Cap holders first to clear the way for vertical
    CSUB    homePistonMotorBoth
    CSUB    homeVerticalMotorBoth
    SGP     GB_HomingDone, GPbank_2, set       // home done

return_FIND_HOME:
    RSUB

//************************************************************************

FIND_HOMES_SHORT:

    SGP     GB_HomingShortDone, GPbank_2, clr  // clear homing done  
    CSUB    checkNoSyringeFH                   // make sure no syringe is in
    GGP     GB_any_Error, GPbank_2             // get any error status
    COMP    ANY_ERROR_EXISTS                   // exists?
    JC      EQ, return_FIND_HOME_SHORT         // yes, return 
    SAP     AP_MaxCurrent, M_headRotateMotor, 0        // Set absolute max. current
    CSUB    homePigHolderMotor                 // Pig and Cap holders first to clear the way for vertical
    CSUB    homeCapHolderMotor
    CSUB    startHomePistonMotor
    CSUB    positionVerticalMotor              // get it out of pig and cap
// extend capHolder
    GGP     GB_CapHoldsSyringe, GPbank_2              // go to required height
    ACO     CAP_POS_COORD, M_capHolderMotor           // target position into coordinate
    MVP     COORD, M_capHolderMotor, CAP_POS_COORD    // run to coord position

    CSUB    PositionHeadRotateMotor
    CSUB    waitHomePistonMotor
    SGP     GB_HomingShortDone, GPbank_2, set  // home done

return_FIND_HOME_SHORT:
    RSUB

//*******************************************
// Name: CLEAR_ALL_ERRORS  
//
// Summary: reset all errors
//*******************************************

CLEAR_ALL_ERRORS:   // FUNC_4

    RST     continueClearErrors                //Stop a running TMCL program. Reset program counter and stack pointer 
                                               // to zero. Reset accumulator and X register to zero. Reset all flags.
continueClearErrors:    // stack is now empty

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE  //   5 
    SGP     GB_activityIsCorrect, GPbank_2, set                //  13  clear activity correct
    SGP     GB_adjustCycle, GPbank_2, clr                      //  13  clear adjust
    SGP     GB_tryAgainCycle, GPbank_2, clr                    //  52  clear tryAgain
    SGP     GB_preFillRequest, GPbank_2, clr                   //  24  clear pre-fill request
    SGP     GB_initialVolume, GPbank_2, clr                    //  15
    SGP     GB_MotorIsMoving, GPbank_2, clr                    //  16
    SGP     GB_PigWasReplaced, GPbank_2, PIG_WAS_REPLACED      // will not check pig replacement on power up
    SGP     GB_inHomeCapHolderMotor, GPbank_2, clr             // do not check 3 times for syringe popout
    SGP     GB_syringeWOcapInPIG, GPbank_2, clr    
    CSUB    INIT
    CSUB    ClearErrorsRAM
    JA      ABORT_NoReport                                     // no return stack

ClearErrorsRAM:
    SGP     GB_any_Error, GPbank_2, clr                   // signal error: general
    SGP     GB_errors_Ver002, GPbank_2, clr               // 28
    SGP     GB_errors_M_verticalMotor, GPbank_2, clr      // 30      
    SGP     GB_errors_M_pigHolderMotor, GPbank_2, clr     // 31
    SGP     GB_errors_M_capHolderMotor, GPbank_2, clr     // 32
    SGP     GB_errors_M_pistonMotor, GPbank_2, clr        // 33
    SGP     GB_errors_M_headRotateMotor, GPbank_2, clr    // 34
    SGP     GB_errors_SyringeIsIn, GPbank_2, clr          // 35
//    SGP     GB_errors_HandIsIn, GPbank_2, clr             // 36
    SGP     GB_errors_SyringeMissing, GPbank_2, clr       // 37
    SGP     GB_errors_VialMissing, GPbank_2, clr          // 38
    SGP     GB_errors_PigMissing, GPbank_2, clr           // 39
    SGP     GB_errors_volumeExceedsLimits, GPbank_2, clr  // 40
    SGP     GB_errors_prefillExeedsLimit, GPbank_2, clr   // 41
    SGP     GB_errors_vialShieldNotOpen, GPbank_2, clr    // 42
    SGP     GB_errors_findHome, GPbank_2, clr             // 43
    SGP     GB_errors_wrong_PC_command, GPbank_2, clr     // 44
    SGP     GB_retreatMovementComplete, GPbank_2, clr    // 198
    SGP     GB_errors_needleInVial, GPbank_2, clr         // 36  erase assume error: the needle is out from the vial
    RSUB

ClearRunningErrors:

    CSUB    INIT
    CSUB    ClearErrorsRAM

    RSGP    GB_any_Error, GPbank_2           // restore parameter from EEPROM. Now we see if errors in EEPROM
    GGP     GB_any_Error, GPbank_2           // read the parameter. if set, reset data in EEPROM
    COMP    set
    JC      NE, endClearRunningErrors               // clear stored errors if needed
     SGP     GB_any_Error, GPbank_2, clr            // signal error: general
     STGP    GB_any_Error, GPbank_2                 // erase any error  
     STGP    GB_errors_Ver002, GPbank_2
     STGP    GB_errors_M_verticalMotor, GPbank_2
     STGP    GB_errors_M_pigHolderMotor, GPbank_2
     STGP    GB_errors_M_capHolderMotor, GPbank_2
     STGP    GB_errors_M_pistonMotor, GPbank_2
     STGP    GB_errors_M_headRotateMotor, GPbank_2
     STGP    GB_errors_SyringeIsIn, GPbank_2
//    STGP    GB_errors_HandIsIn, GPbank_2
     STGP    GB_errors_SyringeMissing, GPbank_2
     STGP    GB_errors_VialMissing, GPbank_2
     STGP    GB_errors_PigMissing, GPbank_2
     STGP    GB_errors_volumeExceedsLimits, GPbank_2
     STGP    GB_errors_prefillExeedsLimit, GPbank_2
     STGP    GB_errors_vialShieldNotOpen, GPbank_2
     STGP    GB_errors_findHome, GPbank_2
     STGP    GB_errors_wrong_PC_command, GPbank_2          // 44

endClearRunningErrors:
    CSUB    GREEN_ON
    RSUB

//*******************************************************************************
// Name: INIT_DRAW_DOSE   (6)
//
// Summary: PC initialises this program after it put the requested option
//
//*******************************************************************************

INIT_DRAW_DOSE:  

//  EI      TI_INPUT2                       //  hands in machine
    DI      TI_STOPLEFT4                    //  Left rotate reference
    EI      TI_STOPLEFT5                    //  syringe pop out interrupt
    DI      TI_STOPRIGHT5                   //  dipper interrupt

// clear errors and check for syringe
    CSUB    ClearRunningErrors                 
    CSUB    checkOkToInitDrawDoze           // check if in right state,         sets STOPPED_ON_ERROR state
    CSUB    checkPrefillVolume              // verify prefill volume,           sets STOPPED_ON_ERROR state
    CSUB    checkNoSyringe                  // check syringe exists,            sets STOPPED_ON_ERROR state
    CSUB    checkCapSensor                  // check cap sensor is not blocked, sets STOPPED_ON_ERROR state
    GGP     GB_any_Error, GPbank_2          // get any error status
    COMP    ANY_ERROR_EXISTS                // exists?
    JC      NE, HandOKinitDraw              // no, continue 
// error exists
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE // (not necesssary) enable easy recovery after hand is out
    JA      returnInitDraw                             

HandOKinitDraw:
    CSUB    FIND_HOMES_SHORT
    GGP     GB_LoadingHight, GPbank_2
    CALCAV  ADD, GB_DELTA_A
    CSUB    moveCoordVertical
// extend capHolder
//    GGP     GB_CapHoldsSyringe, GPbank_2                              // go to required height
//    ACO     CAP_POS_COORD, M_capHolderMotor                           // target position into coordinate
//    MVP     COORD, M_capHolderMotor, CAP_POS_COORD                    // run to coord position
// prefill or regular?
    GGP     GB_preFillRequest, GPbank_2                               // check for requested prefill
    COMP    PRE_FILL_REQUEST                                          // pre-fill?
    JC      NE, waitMotors                                            // if not, continue
initPrefill:                                                          // prefill volume was inserted before by the PC
    CSUB    movePlungerToPrefill
waitMotors:  // wait for both                                         // **** ADD DRAW VOLUME INITIALIZATION ****
    CSUB    waitCapHolder
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH   // Set standby current 
    SAP     AP_StandbyCurrent, M_capHolderMotor, STBY_CUR_CAP_HIGH       // Set standby current
    SGP     GB_CurrentState, GPbank_2, WAITING_DRAW_DOSE

returnInitDraw:
//  DI      TI_INPUT2                       //  hands in machine
    DI      TI_STOPLEFT4                    //  Left rotate reference
    DI      TI_STOPLEFT5                    //  syringe pop out interrupt
    DI      TI_STOPRIGHT5                   //  dipper interrupt

    RSUB

//*******************************************
// Name: DRAW_DOSE  (8)
//
// Summary: draw 
//*******************************************

DRAW_DOSE:
 
//    EI      TI_TIMER0                     //  time calculate
//  EI      TI_INPUT2                       //  hands in machine
    DI      TI_STOPLEFT4                    //  Left rotate reference
    EI      TI_STOPLEFT5                    //  syringe pop out interrupt
    DI      TI_STOPRIGHT5                   //  dipper interrupt

    CSUB    initDeltas
    SGP     GB_drawCycleTime, GPbank_2, 0   // clear draw cycle timer
    SGP     GB_TMCLtickTimer, GPbank_2, 0   // reset the timer // is this supposed to be in GPbank_0 ???
    CSUB    ClearRunningErrors                 
    SGP     GB_syringeWOcapInPIG, GPbank_2, clr    
    CSUB    checkOkToDrawDoze               // check if in right state, sets STOPPED_ON_ERROR state
    CSUB    checkPrefillVolume              // verify prefill volume,   sets STOPPED_ON_ERROR state
    CSUB    checkDrawVolume                 // verify draw volume,      sets STOPPED_ON_ERROR state
    CSUB    checkDipperSensorBlocked        // dipper sensor blocked?
    GGP     GB_any_Error, GPbank_2          // get any error status
    COMP    ANY_ERROR_EXISTS                // any error?
    JC      EQ, returnDrawDose              // yes, return with STOPPED_ON_ERROR state

    CSUB    VERIFY_READY_DRAW               // check if syringe, vial and pig are loaded, checks if PIG was replaced
                                            // keeps STATE WAITING_DRAW_DOSE for easy recovery
    GGP     GB_any_Error, GPbank_2          // get any error status
    COMP    ANY_ERROR_EXISTS                // exists?
    JC      NE, noErrorFound                // yes, return with WAITING_DRAW_DOSE state for easy recovery
 // errors found
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH  // Set standby current 
    SAP     AP_StandbyCurrent, M_capHolderMotor, STBY_CUR_CAP_HIGH      // Set standby current
    JA      returnDrawDose                                     

noErrorFound: 
    CSUB    GREEN_ON
    CSUB    decapSyringe
    SAP     AP_StandbyCurrent, M_capHolderMotor, STBY_CUR_CAP           // Set standby cap  holder current normal
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE       // Set standby hear rotate current normal
  
    CSUB    startPullAir70                                           // if no prefill, pull 70% of the air
    CSUB    moveBelowVial   
    CSUB    waitPiston                 // wait pull air
    CSUB    checkVialShieldOpen
    GGP     GB_any_Error, GPbank_2          // get any error status
    COMP    ANY_ERROR_EXISTS                // exists?
    JC      EQ, returnDrawDose              // yes, return 
    CSUB    insertNeedle
    CSUB    addBacklashPrefill
//if tryAgain, push the liquid in the syringe back to vial
    GGP     GB_tryAgainCycle, GPbank_2     // check for requested operation: try again?
    COMP    TRY_AGAIN_STATE                // tryAgain?
    JC      NE, noTryAgain                 // if no, push 70%air
    CSUB    pushTryAgain                   // push liquid into vial +"push more" 0.015ml
    JA      pushDone
noTryAgain:
    CSUB    push70air
pushDone:
//    CSUB    bubblesOut                                  // pull and push piston to fill the needle with liquid
    CSUB    drawVial
//    CSUB    BubblesVibrateSyringe
    CSUB    drawVialMoreBack
    CSUB    moveSlowlyBottom
    CSUB    bumpPlunger
    
    CSUB    rotateDown
    CSUB    recapSyringe

    EI      TI_STOPRIGHT5              //  dipper interrupt

    CSUB    insertIntoDozeCalib
    CSUB    incrementCycles

    SGP     GB_CurrentState, GPbank_2, WAITING_CHECK_DONE

 // in case we do not want to stop in the dose calibrator, enable following 5 lines
 //   SGP     GB_microLtoWithdraw, GPbank_2, 0      //eliminate filling the syringe
 //   SGP     GB_activityIsCorrect, GPbank_2, clr   // activitity is bad so will recycle after CHECK_DONE
 //   SGP     GB_adjustCycle, GPbank_2, set         //  13  clear adjust
 //   WAIT    TICKS, 0, 200                         // now wait 2 seconds
 //   JA      CHECK_DONE                        

 returnDrawDose:
//    DI      TI_TIMER0  
    DI      TI_STOPLEFT4               //  Left rotate reference
    DI      TI_STOPLEFT5               //  syringe pop out interrupt
    DI      TI_STOPRIGHT5              //  dipper interrupt

    RSUB

//**************************

// Name: CHECK_DONE  (10)
//
// Summary: 
//**************************

CHECK_DONE:

//    DI      TI_TIMER0  
//  EI      TI_INPUT2                  //  hands in machine
    DI      TI_STOPLEFT4               //  Left rotate reference
    EI      TI_STOPLEFT5               //  syringe pop out interrupt
    DI      TI_STOPRIGHT5              //  dipper interrupt

    CSUB    ClearRunningErrors                 
    CSUB    checkOkToCheckDone
    CSUB    checkPigPoppedOut                           // verify that the Pig did not pop out
    GGP     GB_any_Error, GPbank_2                      // get any error status
    COMP    ANY_ERROR_EXISTS                            // exists?
    JC      EQ, returnCheckDone                         // yes, return 

    GGP     GB_any_Error, GPbank_2                      // get any error status
    COMP    ANY_ERROR_EXISTS                            // exists?
    JC      NE, OKanyError                         // no, continue 
    SGP     GB_CurrentState, GPbank_2, WAITING_CHECK_DONE // enable easy recovery after errors
    JA      returnCheckDone                             

OKanyError:
    GGP     GB_activityIsCorrect, GPbank_2              // check for requested operation
    COMP    CORRECT_ACTIVITY                            // verify passed?
    JC      NE, activityNotOK                           // if not, continue

activityOK:
    SGP     GB_preFillRequest, GPbank_2, clr               // mark as no more prefill
    SGP     GB_adjustCycle, GPbank_2, clr                  // clear adjust
    SGP     GB_tryAgainCycle, GPbank_2, clr                // clear tryAgain
//    SGP     GB_initialVolume, GPbank_2, 0                  // clear volume
    SGP     GB_PigWasReplaced, GPbank_2, PIG_NOT_REPLACED  // watch for pig replacement (assume no show)

 // overide GB_PigWasReplaced if in a show
    GGP     GB_ShowOveride, GPbank_2
    COMP    set
    JC      NE, doneShowOverride
    SGP     GB_PigWasReplaced, GPbank_2, PIG_WAS_REPLACED // ignore pig replacement (yes show)

doneShowOverride:
    CSUB    putSyringeInPig

//    DI      TI_TIMER0  
//  DI      TI_INPUT2                  //  hands in machine
    DI      TI_STOPLEFT4               //  Left rotate reference
//  DI      TI_STOPLEFT5               //  syringe pop out interrupt
    DI      TI_STOPRIGHT5              //  dipper interrupt

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    CSUB    INIT_DRAW_DOSE                                 // initialize
    JA      returnCheckDone  

activityNotOK:                                             // need to run again with adjust OR tryAgain
// now check that one and only one of them is ON
    GGP     GB_adjustCycle, GPbank_2                       // check for requested operation
    COMP    ADJUST_STATE                       
    JC      NE, notAdjust                                  // if not, check that yes tryAgain
yesAdjust:
    GGP     GB_tryAgainCycle, GPbank_2                     // if yes adjust, Again should be not
    COMP    TRY_AGAIN_STATE                                // verify passed?
    JC      NE, adjustOrAgain                              // if not, continue
  yesAdjustYesAgain: 
    JA      errorAdjustOrAgain                             // if both YES, error
notAdjust:
//    SGP     GB_initialVolume, GPbank_2, 0                  // clear volume
    GGP     GB_tryAgainCycle, GPbank_2                     // if not adjust, Again should be yes
    COMP    TRY_AGAIN_STATE                                // verify passed?
    JC      EQ, adjustOrAgain                              // if yes, continue
  notAdjustNotAgain: 
    JA      errorAdjustOrAgain                             // if both NOT, error

errorAdjustOrAgain:
    GGP     GB_errors_wrong_PC_command, GPbank_2           // load Ver002 error word
    CALC    OR, BitEr_errorAdjustOrAgain                   // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2           // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2           // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
// move up to enable service        
    GGP     GB_LoadingHight, GPbank_2                      // move vertical to loading hight
    CALCAV  ADD, GB_DELTA_C
    MVPA    ABS, M_verticalMotor                           
    CSUB    waitVertical
    JA      returnCheckDone
      
adjustOrAgain:
//    SGP     GB_adjustCycle, GPbank_2, set                // adjust OR tryAgain will be set by PC
    SGP     GB_preFillRequest, GPbank_2, clr               // mark as no prefill volume adjustment
    CSUB    capIntoCapHolder                               // need to put cap back into cap holder
    SGP     GB_PigWasReplaced, GPbank_2, PIG_WAS_REPLACED  // watch for pig replacement
    SGP     GB_CurrentState, GPbank_2, WAITING_DRAW_DOSE
    CSUB    incrementAdjustments

    JA    DRAW_DOSE                                     // run again. next command exits.
                                                        // if activity bad, PC will run CHECK_DONE again.
returnCheckDone:
    RSUB

//***********************************************************************
// Name: VERIFY_READY_DRAW     
//
// Summary:  checks if the vial' syringe and pig are ready to draw
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

VERIFY_READY_DRAW:    //  checks if syringe, vail and pig are in place

    SGP     GB_readyToDraw, GPbank_2, clr               // not ready to draw (assume)  
    CSUB    verifySyringe
    CSUB    verifyPIG
    CSUB    verifyVIAL
    CSUB    verifyPigReplaced

    GGP     GB_any_Error, GPbank_2                      // get any error status
    COMP    ANY_ERROR_EXISTS                            // exists?
    JC      NE, returnVerify
 // errors
    CSUB    setAnyErrorYellow
    SGP     GB_CurrentState, GPbank_2, WAITING_DRAW_DOSE
    RSUB
returnVerify:
    SGP     GB_readyToDraw, GPbank_2, set               // ready to draw  
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verifySyringe:  // check the syringe status, set the global parameter
                // according to state

    GAP     AP_LeftLimitSwitchState, M_headRef_sensors  // check if syringe is in
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnVerifySyringe                     // syringe is in

syringeMissing:
    SGP     GB_errors_SyringeMissing, GPbank_2, set     // syringe is in
    STGP    GB_errors_SyringeMissing, GPbank_2          // store ready to draw
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnVerifySyringe:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verifyPIG:  // check the Pig status, set the global parameter
            // according to state

    GIO     In_PigInPlace, InBankDigital_0              // check if Pig is in
    COMP    PIG_IS_LOADED                               // is the Pig in?
    JC      NE, noPig                                   // if not, continue

    CSUB    HomePigHolderMotor                          // always look for home
    JA      returnVerifyPig

noPig:
 // declare error
    SGP     GB_errors_PigMissing, GPbank_2, set         // Pig is in
    STGP    GB_errors_PigMissing, GPbank_2              // store ready to draw
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnVerifyPig:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verifyVIAL:  // check the Vial status, set the global parameter
             // according to state

    GIO     In_VialInPlace, InBankDigital_0             // check if Vial is in
    COMP    VIAL_IS_LOADED                              // is the Vial in?
    JC      EQ, returnVerifyVial                        // if not, continue

noVial:
    SGP     GB_errors_VialMissing, GPbank_2, set        // Vial is in
    STGP    GB_errors_VialMissing, GPbank_2             // store ready to draw
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnVerifyVial:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verifyPigReplaced:  // check that the pig was replaced after last Draw to eliminate double syringes
                    // set the global parameter according to state

    GGP     GB_PigWasReplaced, GPBank_2                 // check if was replaced
    COMP    PIG_WAS_REPLACED                            // pig was replaced?
    JC      EQ, returnPigReplaced                       // if not, continue

 // PigNotReplaced
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_pigWasNotReplaced                 // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnPigReplaced:
    RSUB

//*********************************
//*********************************
// Subroutines initialized localy
//*********************************
//*********************************

homeVerticalMotorBoth:  
    SAP       AP_RefSearchMode, M_verticalMotor, APV_RefLeftSwitch + AVP_StartReverse  // set the kind of search just go down
    RFS       START, M_verticalMotor                                // Start reference search, DOWN (right)
    CSUB      waitVerticalRfs
    SAP       AP_RefSearchMode,  M_verticalMotor, APV_RefLeftSwitch // set the kind of search just go up
    RFS       START, M_verticalMotor                                // Start reference search, UP (left)
    CSUB      waitVerticalRfs
    CSUB      positionVerticalMotor                                 // now go up and back to home
    RSUB

positionVerticalMotor:  
    CSUB      homeVerticalMotor                                     // to home switch upwards
    GGP       GB_VerticalHomePos, GPbank_2
    CSUB      moveCoordVertical
    RSUB

homeVerticalMotor:          // to home switch upwards
    SAP       AP_MaxAcceleration, M_verticalMotor, ACC_VERT_HIGH         // Set maximum acceleration
    SAP       AP_RefSearchMode,  M_verticalMotor, APV_RefHomeviaLeftSw   // set the kind of search just go up
    RFS       START, M_verticalMotor                                     // Start home sw search UP, then' if reached ref, Down
    CSUB      waitVerticalRfs
    SAP       AP_MaxAcceleration, M_verticalMotor, ACC_VERT              // Set maximum acceleration
    RSUB

//*********************************

homePigHolderMotorBoth:  
    SAP       AP_StandbyCurrent, M_pigHolderMotor, STBY_CURRENT_PIG_HIGH   // Set standby current
    SAP       AP_RefSearchMode,  M_pigHolderMotor, APV_RefTwoSwitches
    RFS       START, M_pigHolderMotor                             // Start reference search
    CSUB      waitPigHolderRfs
    RSUB

homePigHolderMotor:  
    SAP       AP_StandbyCurrent, M_pigHolderMotor, STBY_CURRENT_PIG_HIGH   // Set standby current
    SAP       AP_RefSearchMode, M_pigHolderMotor, APV_RefLeftSwitch
    RFS       START, M_pigHolderMotor                             // Start reference search
    CSUB      waitPigHolderRfs
    RSUB

//*********************************

homeCapHolderMotorBoth:  
 // set vertical motor current to zero for a case that the cap holder pushes the vertical axis:
    SAP       AP_MaxCurrent, M_headRotateMotor, 0                       // Set absolute max. current
    SAP       AP_RefSearchSpeed, M_capHolderMotor, SEARCH_SPEED_CAP   // speed for search
    SAP       AP_RefSwitchSpeed, M_capHolderMotor, SWITCH_SPEED_CAP   // speed for final search
    SAP       AP_RefSearchMode, M_capHolderMotor, APV_RefTwoSwitches
    RFS       START, M_capHolderMotor                                 // Start reference search
    CSUB      waitCapHolderRfs
    SAP       AP_MaxCurrent, M_headRotateMotor, MAX_CURRENT_ROT        // Set absolute max. current
    RSUB

homeCapHolderMotor:  
    GGP     GB_CurrentState, GPbank_2   // InitDrawDoze can run if WAITING_INIT_DRAW_DOSE or if WAITING_DRAW_DOSE
    COMP    RUNNING_INIT_DRAW_DOSE                                    // RUNNING_INIT_DRAW_DOSE?
    JC      NE, okHomeCapHolder                                       // no, continue
 // set vertical motor current to zero for a case that the cap holder pushes the vertical axis:
    SAP     AP_MaxCurrent, M_headRotateMotor, 0                       // Set absolute max. current
    
okHomeCapHolder:
    SAP       AP_RefSearchSpeed, M_capHolderMotor, SEARCH_SPEED_CAP   // speed for search
    SAP       AP_RefSwitchSpeed, M_capHolderMotor, SWITCH_SPEED_CAP   // speed for final search
    SAP       AP_RefSearchMode, M_capHolderMotor, APV_RefLeftSwitch
    RFS       START, M_capHolderMotor                                 // Start reference search
    CSUB      waitCapHolderRfs
    SAP       AP_MaxCurrent, M_headRotateMotor, MAX_CURRENT_ROT           // Set absolute max. current
    RSUB

//*********************************

homePistonMotorBoth:   
    SAP       AP_RefSearchMode, M_pistonMotor, APV_RefTwoSwitches  
    RFS       START, M_pistonMotor                                 // Start reference search
    CSUB      waitPistonRfs
    GGP       GB_PistonHomePos, GPbank_2                           // go to required height
    CALCAV    SUB, GB_DELTA_D                                         // adjust Thumbrest location from the finger flange in difrenet syringes
    COMP    0
    JC      GE, ResumeHomePistonMotorBoth   
    CALC    LOAD, 0
  ResumeHomePistonMotorBoth:
    MVPA    ABS, M_pistonMotor                        // move, wait later
    CSUB    waitPiston
    RSUB

homePistonMotor:                           // only to home sensor
    CSUB      startHomePistonMotor
    CSUB      waitPistonRfs
    RSUB

startHomePistonMotor:
    SAP       AP_RefSearchMode,  M_pistonMotor, APV_RefLeftSwitch      //
    RFS       START, M_pistonMotor                                       // Start reference search
    RSUB

waitHomePistonMotor:                      // wait home sensor and position
    CSUB      waitPistonRfs
    GGP       GB_PistonHomePos, GPbank_2                           // go to required height
    CALCAV    SUB, GB_DELTA_D                                         // adjust Thumbrest location from the finger flange in difrenet syringes
    COMP    0
    JC      GE, ResumeWaitHomePistonMotor
    CALC    LOAD, 0
  ResumeWaitHomePistonMotor:
    MVPA    ABS, M_pistonMotor                        // move, wait later
    CSUB    waitPiston
    RSUB

//*********************************

PositionHeadRotateMotor:   
    CSUB      HomeHeadRotateMotor
    GGP       GB_HeadRotateHomePos, GPbank_2                       // go to required height
    CSUB      moveCoordRotate                                      // move, wait and error if delay
    RSUB

HomeHeadRotateMotor:   
    CSUB      homeHeadRotateMotorFast                                       // find fast, before slow
    CSUB      homeHeadRotateMotorSlow                                       // find fast, before slow
    RSUB

homeHeadRotateMotorSlow:
    SAP       AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT_SLOW   // speed for search slow
    SAP       AP_RefSwitchSpeed, M_headRotateMotor, SWITCH_SPEED_ROT_SLOW   // speed for final search
    SAP       AP_RefSearchMode,  M_headRotateMotor, APV_RefLeftSwitch  
    RFS       START, M_headRotateMotor                                      // Start reference search
    CSUB      waitRotateRfsShort
    RSUB

homeHeadRotateMotorFast:   
    SAP       AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT   // speed for search
    SAP       AP_RefSwitchSpeed, M_headRotateMotor, SWITCH_SPEED_ROT   // speed for final search
    SAP       AP_RefSearchMode,  M_headRotateMotor, APV_RefLeftSwitch  
    RFS       START, M_headRotateMotor                             // Start reference search
    CSUB      waitRotateRfs
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkVialShieldOpen:

    GIO     In_VailShieldOpen, InBankDigital_0                      // get state of vial shield
    COMP    VIAL_IS_UNSHIELDED                                      // is the vial shield out?
    JC      EQ, unshielded 
    WAIT    TICKS, 0, 100                                           // wait 1 [s]
    GIO     In_VailShieldOpen, InBankDigital_0                      // get state of vial shield
    COMP    VIAL_IS_UNSHIELDED                                      // is the vial shield out?
    JC      EQ, unshielded 
    WAIT    TICKS, 0, 100                                           // wait 1 [s]
    GIO     In_VailShieldOpen, InBankDigital_0                      // get state of vial shield
    COMP    VIAL_IS_UNSHIELDED                                      // is the vial shield out?
    JC      EQ, unshielded 
    WAIT    TICKS, 0, 100                                           // wait 1 [s]
    GIO     In_VailShieldOpen, InBankDigital_0                      // get state of vial shield
    COMP    VIAL_IS_UNSHIELDED                                      // is the vial shield out?
    JC      EQ, unshielded 

    CSUB    setStateSTOPPED_ON_ERROR
    SGP     GB_errors_vialShieldNotOpen, GPbank_2, set              // declare any error  
    STGP    GB_errors_vialShieldNotOpen, GPbank_2                   // declare any error  
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    STGP    GB_CurrentState, GPbank_2

unshielded:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verticalMotorTOerr:  

    CSUB    setAnyError
    GGP     GB_errors_M_verticalMotor, GPbank_2         // load piston error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_verticalMotor, GPbank_2         // and write again
    STGP    GB_errors_M_verticalMotor, GPbank_2         // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    STGP    GB_CurrentState, GPbank_2
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

InDoseCalibratorTOerr:  

    CSUB    setAnyError
    GGP     GB_errors_M_verticalMotor, GPbank_2         // load piston error word
    CALC    OR, BitEr_stuckInDoseCalibrator             // add the error bit
    AGP     GB_errors_M_verticalMotor, GPbank_2         // and write again
    STGP    GB_errors_M_verticalMotor, GPbank_2         // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    STGP    GB_CurrentState, GPbank_2
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

pigMotorTOerr:   

    CSUB    setAnyError
    GGP     GB_errors_M_pigHolderMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_pigHolderMotor, GPbank_2        // and write again
    STGP    GB_errors_M_pigHolderMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    STGP    GB_CurrentState, GPbank_2
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

capHolderMotorTOerr:  

    CSUB    setAnyError
    GGP     GB_errors_M_capHolderMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_capHolderMotor, GPbank_2        // and write again
    STGP    GB_errors_M_capHolderMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    STGP    GB_CurrentState, GPbank_2
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

pistonMotorTOerr:   

    CSUB    setAnyError
    GGP     GB_errors_M_pistonMotor, GPbank_2           // load piston error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_pistonMotor, GPbank_2           // and write again
    STGP    GB_errors_M_pistonMotor, GPbank_2           // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    STGP    GB_CurrentState, GPbank_2
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

headRotateMotorTOerr:

    CSUB    setAnyError
    GGP     GB_errors_M_headRotateMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                            // add the error bit
    AGP     GB_errors_M_headRotateMotor, GPbank_2        // and write again
    STGP    GB_errors_M_headRotateMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    STGP    GB_CurrentState, GPbank_2
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkNoSyringe:

    GAP     AP_LeftLimitSwitchState, M_headRef_sensors  // check if syringe is in
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      NE, returnCheckNoSyringe                    // if not, continue
    // syringe found, signal errors
    SGP     GB_errors_SyringeIsIn, GPbank_2, set        // signal error: syringe
    STGP    GB_errors_SyringeIsIn, GPbank_2             // declare syringe IN error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnCheckNoSyringe:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkCapSensor:

    GIO     In_CapHolderHomeNeedle, InBankDigital_0     // check if cap sensor is blocked by head
    COMP    CAP_SENSOR_BLOCKED                          // is the syringe in?
    JC      NE, returncheckCapSensor                    // if not, continue
    // sensor is blocked, signal errors
    SAP     AP_MaxCurrent, M_headRotateMotor, 0         // Set absolute max. current to enable fix
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_LOW   // Set absolute max. current to enable fix
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_capSensorBlocked                  // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returncheckCapSensor:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkSyrPoppedOut:

    GAP     AP_LeftLimitSwitchState, M_headRef_sensors  // check if syringe is in
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnSyrPoppedOut                      // if in, continue to check vial
 // syringe popped out, signal errors
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_syringePoppedOut                  // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      ABORT

returnSyrPoppedOut:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkSyrPoppedOut3Times:

    GAP     AP_LeftLimitSwitchState, M_headRef_sensors  // check if syringe is in
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnSyrPoppedOut3                     // if in, continue to check vial
 // try again
    WAIT    TICKS, 0, WAIT_TICKS_200ms                  // wait ticks as in A
    GAP     AP_LeftLimitSwitchState, M_headRef_sensors  // check if syringe is in
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnSyrPoppedOut3                     // if in, continue to check vial
 // and again
    WAIT    TICKS, 0, WAIT_TICKS_200ms                  // wait ticks as in A
    GAP     AP_LeftLimitSwitchState, M_headRef_sensors  // check if syringe is in
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnSyrPoppedOut3                     // if in, continue to check vial

 // syringe popped out, signal errors
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_syringePoppedOut                  // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      ABORT

returnSyrPoppedOut3:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkVialPoppedOut:

    GIO     In_VialInPlace, InBankDigital_0             // check if syringe is in
    COMP    VIAL_IS_LOADED                              // is the syringe in?
    JC      EQ, returnVialPoppedOut                  // if not, continue
 // vial popped out, signal errors
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_VialPoppedOut                     // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      ABORT

returnVialPoppedOut:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkPigPoppedOut:

    GIO     In_PigInPlace, InBankDigital_0              // check if Pig is in
    COMP    PIG_IS_LOADED                               // is the Pig in?
    JC      EQ, returnPigPoppedOut                      // if in, continue to check vial
 // pig popped out, signal errors
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_PigPoppedOut                      // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnPigPoppedOut:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkNoSyringeFH:

    GAP     AP_LeftLimitSwitchState, M_headRef_sensors  // check if syringe is in
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      NE, noSyringeFH                             // if not, continue
    // syringe found, signal errors
    GGP     GB_errors_findHome, GPbank_2                // load piston error word
    CALC    OR, BitEr_syringeIsInwhileFindHome          // add the error bit
    AGP     GB_errors_findHome, GPbank_2                // and write again
    STGP    GB_errors_findHome, GPbank_2                // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnCheckNoSyringeFH

noSyringeFH:
    GGP     GB_errors_findHome, GPbank_2                // load piston error word
    CALC    OR, BitEr_syringeIsInwhileFindHome          // add the error bit
    CALC    XOR, BitEr_syringeIsInwhileFindHome         // Clear the error bit
    AGP     GB_errors_findHome, GPbank_2                // and write again
    STGP    GB_errors_findHome, GPbank_2                // and store it

returnCheckNoSyringeFH:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkPrefillVolume:
    GGP     GB_preFillRequest, GPbank_2                 // check if requested prefill
    COMP    PRE_FILL_REQUEST                            // pre-fill?
    JC      NE, returnPrefillVolume                     // if no request, return
 // check if preFill Volume exeeds prefill limit
    GGP     GB_preFillVolume, GPbank_2                  // load the prefill volume [uL] into A
    CALCX   LOAD                                        // copy A to X
    GGP     GB_Limit_for_Prefill_current, GPbank_2      // load prefill limit into A
    CALCX   SUB                                         // A - X  now if positive, OK
    COMP    0
    JC      LT, prefillExeedsLimit                      // too much' error

 // check if preFill Volume is negative
    GGP     GB_preFillVolume, GPbank_2                  // load the prefill volume [uL] into A
    COMP    0
    JC      GE, returnPrefillVolume                      // ok, return

prefillExeedsLimit:
    SGP     GB_errors_prefillExeedsLimit, GPbank_2, set // signal error: syringe
    STGP    GB_errors_prefillExeedsLimit, GPbank_2      // declare vail, syringe or pig error  
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnPrefillVolume:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkDrawVolume:
// reset initialVolume
    GGP     GB_adjustCycle, GPbank_2       
    COMP    ADJUST_STATE                       
    JC      EQ, prefillOrRegular                         // if not, check that yes tryAgain
    SGP     GB_initialVolume, GPbank_2, 0                // initial volume is not 0 only in adjust cycle
prefillOrRegular:
    GGP     GB_preFillRequest, GPbank_2                  // check if requested prefill
    COMP    PRE_FILL_REQUEST                             // pre-fill?
    JC      NE, checkVolume                              // if EQ, jump
    GGP     GB_preFillVolume, GPbank_2                   // load the prefill volume [uL] into A (the current volume is 0)
    AGP     GB_initialVolume, GPbank_2                   // save into the current volume (for volume testing)
checkVolume:
// clear initial volume if tryAgain
    GGP     GB_tryAgainCycle, GPbank_2                   // check for requested operation: try again?
    COMP    TRY_AGAIN_STATE                              // tryAgain?
    JC      NE, checkMaximum                             // if yes, clear initial volume
    SGP     GB_initialVolume, GPbank_2, 0                // clear volume
checkMaximum:
 // check if too much
    GGP     GB_initialVolume, GPbank_2                   // load the initial volume [uL] into A
    CALCAV  ADD, GB_microLtoWithdraw                     // add the draw volume
    AGP     GB_initialVolume, GPbank_2                   // save into the current volume (for volume testing)
    CALCAV  SUB, GB_Max_Volume_current                   // sub max volume permitted from the draw volume
    COMP    0                                            // more than maximum permitted?
    JC      GT, drawVolumeExeeds                         // no, report error and stop

 // check minimum
    GGP     GB_preFillRequest, GPbank_2                  // check if requested prefill
    COMP    PRE_FILL_REQUEST                             // pre-fill?
    JC      NE, checkMinimumNoPrefill                    // if EQ, jump
 // check prefill minimum
    GGP     GB_initialVolume, GPbank_2                   // load the draw volume [uL] into A
    CALCX   LOAD                                         // copy A to X
    COMP    MINIMUM_DRAW_PREFILL_uL                      // 0
    JC      GE, returnDrawLimit                          // yes, exit
    JA      drawVolumeExeeds                             // report error
 checkMinimumNoPrefill:
    GGP     GB_initialVolume, GPbank_2                   // load the draw volume [uL] into A
    COMP    MINIMUM_DRAW_VOLUME_uL                   
    JC      GE, returnDrawLimit                          // yes, exit
                                                         // no. report error and stop 
drawVolumeExeeds:
    SGP     GB_errors_volumeExceedsLimits, GPbank_2, set // signal error: syringe
    STGP    GB_errors_volumeExceedsLimits, GPbank_2      // declare vail, syringe or pig error  
    GGP     GB_initialVolume, GPbank_2                   // load the initial volume [uL] into A
    CALCAV  SUB, GB_microLtoWithdraw                     // restore the initialVolume 
    AGP     GB_initialVolume, GPbank_2                   // save into the current volume (for volume testing)
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnDrawLimit:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkOkToInitDrawDoze:

    CSUB    clrErrors_wrong_PC_command
    GGP     GB_CurrentState, GPbank_2   // InitDrawDoze can run if WAITING_INIT_DRAW_DOSE or if WAITING_DRAW_DOSE
    COMP    WAITING_INIT_DRAW_DOSE                       // WAITING_INIT_DRAW_DOSE?
    JC      EQ, okToInitDrawDoze                         // yes, return
    GGP     GB_CurrentState, GPbank_2                    // no, try next
    COMP    WAITING_DRAW_DOSE                            // WAITING_DRAW_DOSE?
    JC      EQ, okToInitDrawDoze                         // yes, return
    // InitDrawDoze does not fit, signal errors
    GGP     GB_errors_wrong_PC_command, GPbank_2         // load error word
    CALC    OR, BitEr_expecting_GP5_10_OR_30             // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2         // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2         // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnCheckInitDraw

okToInitDrawDoze:    
    SGP     GB_CurrentState, GPbank_2, RUNNING_INIT_DRAW_DOSE

returnCheckInitDraw:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkOkToDrawDoze:

    CSUB    clrErrors_wrong_PC_command
    GGP     GB_CurrentState, GPbank_2                      // current state to A
    COMP    WAITING_DRAW_DOSE
    JC      EQ, okToDrawDoze                               // if EQ, continue

 // this not is the time for DrawDose
    GGP     GB_errors_wrong_PC_command, GPbank_2           // load  error word
    CALC    OR, BitEr_expecting_WAITING_DRAW_DOSE          // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2           // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2           // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnCheckOkDraw

okToDrawDoze:    
    SGP     GB_CurrentState, GPbank_2, RUNNING_DRAW_DOSE
returnCheckOkDraw:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkDipperSensorBlocked:

    GAP     AP_RightLimitSwitchState, M_headRef_sensors    // check if dipper is blocked
    COMP    DIPPER_IS_BLOCKED
    JC      NE, okToDrawDoze                               // if EQ, continue

 // dipper is blocked
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_DipperSensorBlocked               // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR

returnDipper:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkOkToCheckDone:

    CSUB    clrErrors_wrong_PC_command
    GGP     GB_CurrentState, GPbank_2                      // current state to A
    COMP    WAITING_CHECK_DONE
    JC      EQ, okToCheckDone                              // if EQ, continue
    // syringe found, signal errors
    GGP     GB_errors_wrong_PC_command, GPbank_2           // load  error word
    CALC    OR, BitEr_expecting_WAITING_CHECK_DONE         // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2           // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2           // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnOkToCheckDone

okToCheckDone:    
    SGP     GB_CurrentState, GPbank_2, RUNNING_CHECK_DONE

returnOkToCheckDone:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

movePlungerToPrefill:

    GGP     GB_preFillVolume, GPbank_2                  // load the prefill volume [uL] into A
//    CALCX   LOAD                                        // move it to X [uStep/100uL]
//    GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
//    CALCX   MUL                                         // A <-- A*X [uSteps*100]
//    CALC    DIV, 100                                    // now in uSteps
//    CALCX   LOAD                                        // move it to X [uStep/100uL]
//    GGP     GB_PistonHomePos, GPbank_2                  // go to required height
//    CALCAV  SUB, GB_DELTA_D                 // adjust Thumbrest location from the finger flange in difrenet syringes
//    CALCX   ADD                                         // add home of piston
    CALC    ADD, ADD_FOR_PREFILL_uL                       // pull liquid from needle to eliminate drop
    CSUB    moveCoordPistonREL_uL
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

decapSyringe:    // 

//    GGP     GB_NeedleDecapLen_current, GPbank_2
    GGP     GB_LoadingHight, GPbank_2                // get reference height
    // CALCAV  SUB, GB_Cap_Length_current_us            // add delta for required height
    CALC    ADD, DECAP_HEIGHT_DELTA                  // add delta for required height
    CALCAV  ADD, GB_DELTA_B                          // add delta when pointing down (for abs movment in vert)
    MVPA    ABS, M_verticalMotor                     // move to location
    CSUB    waitVertical
    CSUB    homeCapHolderMotor                      // cap holder out of the way
//    CSUB    checkSyrPoppedOut                       // verify that the syringe did not pop out
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

startPullAir70:  //  if no prefill, pull 70% of the air

    GAP     AP_ActualPosition, M_pistonMotor            // get current position to A
    CALCVA  LOAD, GB_reservedPisonLocation
    GGP     GB_preFillRequest, GPbank_2                 // check for requested operation: prefill?
    COMP    PRE_FILL_REQUEST                            // prefill?
    JC      EQ, returnStartPullAir70                    // prefill? do not 70%
    GGP     GB_adjustCycle, GPbank_2                    // check for requested operation: adjust?
    COMP    ADJUST_STATE                                // adjust?
    JC      EQ, returnStartPullAir70                    // if yes, do not 70%
    GGP     GB_tryAgainCycle, GPbank_2                  // check for requested operation: try again?
    COMP    TRY_AGAIN_STATE                             // tryAgain?
    JC      EQ, returnStartPullAir70                    // if yes, do not 70%
  // if noPrefill or adjust, pull air 70%
    GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
    CALCAV  MUL, GB_microLtoWithdraw               // load the withdraw volume [uL] into A
    CALC    DIV, 100                                    // now in uSteps
    CALCAV  MUL, GB_airToPullBefore                // get the "70%"
    CALC    DIV, 100                                    // now in uSteps
    // CALCX   LOAD
    // GAP     AP_ActualPosition, M_pistonMotor            // get current position to A
    // CALCX   ADD                                         // add current position to required relative
    CSUB    moveCoordPistonREL
/////////////////////////////////////////////////////////////
  // // // // // if noPrefill or adjust, pull air 70%
    // // // // GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
    // // // // CALCX   LOAD                                        // move it to X [uStep/100uL]
    // // // // GGP     GB_microLtoWithdraw, GPbank_2               // load the withdraw volume [uL] into A
    // // // // CALCX   MUL                                         // A <-- A*X [uSteps*100]
    // // // // CALC    DIV, 100                                    // now in uSteps
    // // // // CALCX   LOAD                                        // copy to X
    // // // // GGP     GB_airToPullBefore, GPbank_2                // get the "70%"
    // // // // CALCX   MUL                                         // calculate 70%
    // // // // CALC    DIV, 100                                    // now in uSteps
    // // // // CALCX   LOAD                                        // relative uSteps in X
    // // // // GAP     AP_ActualPosition, M_pistonMotor            // get current position to A
    // // // // CALCX   ADD                                         // add current position to required relative
    // // // // ACO     PISTON_POS_COORD, M_pistonMotor             // target position into coordinate #1
    // // // // MVP     COORD, M_pistonMotor, PISTON_POS_COORD      // run to coord 1 position
// // // // returnStartPullAir70:
/////////////////////////////////////////////////////////////
returnStartPullAir70:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

openVialCover:

    SIO    Out_ShieldVail, OutBank_2, 1        // open cover
//  wait cover to open
    WAIT    TICKS, 0, 5

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

closeVialCover:

    SIO     Out_ShieldVail, OutBank_2, 0        // close cover
//  wait cover to close
    WAIT    TICKS, 0, 6

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveBelowVial:   //   

    MVP     COORD, $51, BELOW_VIAL_COORD                 // interpolate down and CCW to position
    CSUB    waitRotateLong
    CSUB    waitVerticalLong
//    CSUB    checkSyrPoppedOut                           // verify that the syringe did not pop out
    CSUB    checkVialPoppedOut                          // verify that the syringe did not pop out
    CSUB    findCenterOfNeedleSensor
    CSUB    checkBentLimit
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

findCenterOfNeedleSensor:

// first check parameter validity
// GE than 10? if y, set to 0
    GGP     GB_adjustNeedleSensingHightMM, GPbank_2       // check the GP 0<=GP<=700   0<=GP<=MAX_RANDOM_IN_VIAL
    COMP    10
    JC      LE, checkMaxAdjust
    SGP     GB_adjustNeedleSensingHightMM, GPbank_2, 0
    JA      calcSensingHight
// LE than -5? if y, set to 0
checkMaxAdjust:
    GGP     GB_adjustNeedleSensingHightMM, GPbank_2      // check the GP 0<=GP<=700   0<=GP<=MAX_RANDOM_IN_VIAL
    COMP    -5
    JC      GT, calcSensingHight
    SGP     GB_adjustNeedleSensingHightMM, GPbank_2, 0

calcSensingHight:
    CSUB    openVialCover
    GGP     GB_adjustNeedleSensingHightMM, GPbank_2     // load mm to move down
    CALC    MUL, verticalMicroStepsPerMM                // noe in staeps
    CALCAV  ADD, GB_BumpPosVert                         // add the bump position
    CALC    ADD, VERTICAL_FOR_NEEDLE_DELTA              // now at the needle sensor for default distance
    CALCAV  SUB, GB_DELTA_B                          // sub delta when pointing up (for abs movment in vert)
    MVPA    ABS, M_verticalMotor                        // move, wait later
 // adjust for home position
    GGP     GB_HeadRotateHomePos, GPbank_2               // where was the cap location (80)
    CALC    ADD, HEAD_ROTATE_NEEDLE_SEARCH               // add current rotation location (31920)
    CSUB    moveCoordRotate                              // move, wait and error if delay
    CSUB    waitVertical
 // first RFS
    SAP     AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT_SLOW   // speed for search
    SAP     AP_RefSwitchSpeed, M_headRotateMotor, SWITCH_SPEED_ROT_SLOW   // speed for final search
    SAP     AP_RefSearchMode,  M_headRotateMotor, APV_RefHomeRight        // search needle  
    RFS     START, M_headRotateMotor                                      // Start reference search
    WAIT    RFS, M_headRotateMotor, WAIT_NEEDLE_REF_FIRST                 // wait till reaches location or 0.8 seconds
    JC      ETO, secondRFSback                                            // timeout occured
    JA      endFindNeedle
secondRFSback:
//    MST     M_headRotateMotor
    RFS     STOP, M_headRotateMotor                                  // Start reference search
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_SHORT                 // wait till stops or 6 seconds
    SAP     AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT   // speed for search
    SAP     AP_RefSearchMode,  M_headRotateMotor, APV_RefHomeLeft    // search needle  
    RFS     START, M_headRotateMotor                                 // Start reference search
    CSUB    waitRotateRfsNeedleSecond
endFindNeedle:
    SAP     AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT   // speed for search
    SAP     AP_RefSwitchSpeed, M_headRotateMotor, SWITCH_SPEED_ROT   // speed for final search

    GAP     AP_LastRefPosition, M_headRotateMotor                    // get position of reference
    AGP     GB_lastTopRefPosition, GPBank_2                          // remember position of reference
    GAP     AP_LastRefPosition, M_headRotateMotor                    // get position of reference
    AAP     AP_ActualPosition, M_headRotateMotor                     // set the axis parameter
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkBentLimit:

    GGP     GB_lastTopRefPosition, GPBank_2                     // get current position
    CALCX   LOAD                                                // copy adjustment to X
    GGP     GB_CenterOfVial, GPbank_2
    CALCX   SUB
    CALCX   LOAD                                                // copy adjustment to X
    AGP     GB_NeedleVialError, GPbank_2                        // save error
    COMP    limitNeedleBentMicroS                               // error greater than limit?
    JC      GE, stopLimitBentNeedle                             // yes, do not calculate
    GGP     GB_NeedleVialError, GPbank_2                        // reload error
    COMP    -limitNeedleBentMicroS                              // error less that than negative limit?
    JC      LE, stopLimitBentNeedle
    JA      returnFindCenter

stopLimitBentNeedle:
    CSUB    rotateDown 
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_needleBentRotate                  // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR
    JA      ABORT_NoReport

returnFindCenter:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

insertNeedle:    // 

 // randomly move the needle right or left +/-20 us (+/-0.5mm)

    CSUB    getRandom
    MVPA    REL, M_headRotateMotor                       // move to random location. A holds the amount
    CSUB    waitRotate  
  
    SGP     GB_errors_needleInVial, GPbank_2, set     // assume error: the needle is in the vial
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_TO_VIAL // Set maximum positioning speed
    GGP     GB_BumpPosVert, GPbank_2                // get bump height
    CALC    ADD, VERTICAL_IN_VIAL_DELTA            // add delta for required height ~ 10mm
    CALCAV  SUB, GB_DELTA_B                       // sub delta when pointing up (for abs movment in vert)
    MVPA    ABS, M_verticalMotor                 // move to location
    CSUB    waitVertical
    CSUB    checkVialPoppedOut                 // verify that the vial did not pop out
    
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  randomUSteps = uStepsPerMM*uMRandom/1000
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
getRandom:
// first check parameter validity
// GE than 0? if less, set to 0
    GGP     GB_microMeterRandom, GPbank_2          // check the GP 0<=GP<=700   0<=GP<=MAX_RANDOM_IN_VIAL
    COMP    0
    JC      GE, checkMaxRand
    SGP     GB_microMeterRandom, GPbank_2, 0
    JA      calcRandom
// LE than MAX_RANDOM_IN_VIAL? if more, set to 0
checkMaxRand:
    GGP     GB_microMeterRandom, GPbank_2          // check the GP 0<=GP<=700   0<=GP<=MAX_RANDOM_IN_VIAL
    COMP    MAX_RANDOM_IN_VIAL
    JC      LE, calcRandom
    SGP     GB_microMeterRandom, GPbank_2, RANDOM_um_TO_MOVE_DEF

calcRandom:
    GGP     GB_RandomNumber, GPbank_0              // get a random number (0. . . 2147483647)
    CALC    SUB, 1073741820                        // sub half to get  -107374182 to + 107374182
    CALC    DIV, 1000                              
    CALCAV  MUL, GB_microMeterRandom               
    CALC    DIV, 1073741820/rotateMicroStepsPerMM  // div to get +/-17 INTO A
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

addBacklashPrefill:

checkBacklash:
    GGP     GB_preFillRequest, GPbank_2                 // check for requested operation: prefill?
    COMP    PRE_FILL_REQUEST                            // yes? then no backlash
    JC      EQ, addPrefill                              // if yes, continue
    GGP     GB_adjustCycle, GPbank_2                    // check for requested operation: adjust?
    COMP    ADJUST_STATE                                // adjust? do not backlash twice
    JC      EQ, returnAddBacklashPrefill                // if yes, do not backlash
  // not prefill and not adjust
//    GGP     PISTON_BACKLASH_uL 
//    CALC    MUL, -1
//    CSUB    moveCoordPistonREL_uL
    JA      returnAddBacklashPrefill
addPrefill:
    CALC    LOAD, ADD_FOR_PREFILL_uL                       // pull liquid from needle to eliminate drop
    CALC    MUL, -1
    CSUB    moveCoordPistonREL_uL
//    MVP     REL, M_pistonMotor, -ADD_FOR_PREFILL        // move back "anti drops" if prefill
//    CSUB    waitPiston
returnAddBacklashPrefill:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

push70air:

    GGP     GB_preFillRequest, GPbank_2                 // check for prefill operation
    COMP    PRE_FILL_REQUEST                            // prefill?
    JC      EQ, returnPush70Air                         // if not, continue
    GGP     GB_adjustCycle, GPbank_2                    // check for requested operation: adjust?
    COMP    ADJUST_STATE                                // adjust? do not 70% 
    JC      EQ, returnPush70Air                         // if yes, do not 70%

    // GGP     GB_microLtoWithdraw, GPbank_2               // load the withdraw volume [uL] into A
    // CALCAV  MUL, GB_airToPullBefore                     // get the "70%"
    // CALC    DIV, -100                                    // A = 70% in uL
    // CSUB    moveCoordPistonREL_uL
    CALCAV  LOAD, GB_reservedPisonLocation
    CSUB    moveCoordPiston

returnPush70Air:
    CSUB    pushPistonMore
    WAIT    TICKS, 0, WAIT_TICKS_PUSH_AIR               // wait 
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

pushTryAgain:     // push liquid into vial +"push more" 0.015ml

    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_TRYAGAIN  // Set slow positioning speed
    GGP     GB_PistonHomePos, GPbank_2                                          // go to required height
    CALCAV  SUB, GB_DELTA_D                                         // adjust Thumbrest location from the finger flange in difrenet syringes
    CSUB    moveCoordPiston                                                     // move, wait and error if delay
    CSUB    pushPistonMore
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

pushPistonMore:
    CALC    LOAD, -PUSH_PISTON_MORE_uL
    CSUB    moveCoordPistonREL_uL
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// bubblesOut:   // disabled // pull and push piston to fill the needle with liquid 
// // GB_pistonMicroStepPer100microL   = 146   // = 2083

  // // Set highest positioning speed for bubbles destroy
    // SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_BUBBLE   // Set slow positioning speed
    // CALC    LOAD, BUBBLES_PULL_uL                    // A = uL to pull
    // CALCAV  MUL, GB_pistonMicroStepPer100microL      // A = 100 * micro steps to go
    // CALC    DIV, 100                                 // A = micro steps to go
    // MVPA    REL, M_pistonMotor
    // CSUB    waitPiston
// //    CSUB    BubblesVibrateSyringe
    // WAIT    TICKS, 0, WAIT_TICKS_BUBBLES             // wait 
    // SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_BUBBLE_BACK   // Set slow positioning speed
    // CALC    LOAD, BUBBLES_PULL_uL                    // A = uL to pull
    // CALCAV  MUL, GB_pistonMicroStepPer100microL      // A = 100 * micro steps to go
    // CALC    DIV, -100                                // A = micro steps to go
    // MVPA    REL, M_pistonMotor
    // CSUB    waitPiston
    // WAIT    TICKS, 0, WAIT_TICKS_BUBBLES_BACK        // wait 
    // RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

drawVial:    // just pull to required volume


// piston more first
    CALCV   LOAD, GB_minDrawPistonTemp_uL, 0 // assume prefil or adjust

    GGP     GB_preFillRequest, GPbank_2                                     // check for requested operation: "more"?
    COMP    PRE_FILL_REQUEST                                                // yes? then no "more"
    JC      EQ, drawAfterMore                                               // if yes, continue
    GGP     GB_adjustCycle, GPbank_2                                        // check for requested operation: "more"?
    COMP    ADJUST_STATE                                                    // adjust? do not "more"
    JC      EQ, drawAfterMore                                               // if yes, do not "more"
// not prefill, not adjust  move piston 1mL
                        
                      
    CALCV   LOAD, GB_minDrawPistonTemp_uL, MIN_DRAW_PISTON_uL               // no prefil or adjust, just draw the required amount later
// move "more" 0.5 mL
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_MORE  // Set slow positioning speed (200)
//****
    CALC    LOAD, PISTON_MORE_uL + PUSH_PISTON_MORE_uL
    CSUB    moveCoordPistonREL_uL
//****
// move 1mL
//****
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_DRAW  // Set speed to destroy bubble  (1800)
    CALC    LOAD, MIN_DRAW_PISTON_uL                                        // load the 1mL volume [uL] into A

    CSUB    moveCoordPistonREL_uL
                              
//****
drawAfterMore:
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST       // Set maximum positioning speed, after the 1ml, draw slower (800)
    GGP     GB_microLtoWithdraw, GPbank_2                                   // load the 1mL volume [uL] into A
    CALCAV  SUB, GB_minDrawPistonTemp_uL                 // if 0, will keep the draw, if 1mL, will adjust to compensate the previous 1mL move for bubbles          
    COMP    0
    JC      GT, moreThanOneMl
    CSUB    waitAfterDraw                            // wait here if after that will go up.
moreThanOneMl:                                    
    GGP     GB_microLtoWithdraw, GPbank_2            // load the 1mL volume [uL] into A
    CALCAV  SUB, GB_minDrawPistonTemp_uL             // if 0, will keep the draw, if 1mL, will adjust to compensate the previous 1mL move for bubbles          
    CSUB    moveCoordPistonREL_uL

    GGP     GB_microLtoWithdraw, GPbank_2            // load the 1mL volume [uL] into A
    CALCAV  SUB, GB_minDrawPistonTemp_uL             // if 0, will keep the draw, if 1mL, will adjust to compensate the previous 1mL move for bubbles          
    COMP    0                                        // check if more ore less than 1ml
    JC      LE, returnDrawVial                       // no need to wait when going upwards
    CSUB    waitAfterDraw

returnDrawVial:

    GGP     GB_preFillRequest, GPbank_2                                     // check for requested operation: "more"?
    COMP    PRE_FILL_REQUEST                                                // yes? then no "more"
    JC      EQ, skipTapTapRinse                                               

    CSUB    tapTap                                   // tap the syringe 
    CSUB    tapTap                                  // tap the syringe 
    CSUB    tapTap                                 // tap the syringe 
    CSUB    tapTap                                // tap the syringe 
    CSUB    tapTap                               // tap the syringe 
    CSUB    tapTap                              // tap the syringe 
                                               //
    CALC    LOAD,  300                        // load the 0.3mL volume [uL] into A
    CSUB    moveCoordPistonREL_uL            //
    CALC    LOAD, -300                      // load the 0.3mL volume [uL] into A
    CSUB    moveCoordPistonREL_uL          //
skipTapTapRinse:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

tapTap: // use vial shield cover to tap the syringe

    CSUB    closeVialCover
    CSUB    openVialCover

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

drawVialMoreBack:    // just pull to required volume
// Adjust more backwards speed according to the delay time that is related to the gauge and length

                                                                                               
    CALC    LOAD, MAX_POS_SPEED_PIST_MORE_BACK          // load default speed to A
    CALC    MUL, DEF_DRAW_WAIT_TIME                     // and multiply by the default wait time
    CALCAV  DIV, GB_DrawWaitTime                        // divide A by the final wait time
    AAP     AP_MaxPositioningSpeed, M_pistonMotor       // Set more back positioning speed
                                                                                               
                                                                                                                 

  // always push for later bump
//*****
    CALC    LOAD, -BUMP_DOWN_REL_uL
    CSUB    moveCoordPistonREL_uL
//*****
  // adjust prefill anti drops 
    GGP     GB_preFillRequest, GPbank_2                 // check for requested operation: "more"?
    COMP    PRE_FILL_REQUEST                            // yes? then no "more"
    JC      NE, notPrefill                              // if yes, continue
    JA      returnMoreBack
notPrefill:
    GGP     GB_adjustCycle, GPbank_2                    // check for requested operation: "more"?
    COMP    ADJUST_STATE                                // adjust? do not "more"
    JC      EQ, returnMoreBack                          // if yes, do not "more"
// "more" if no prefil & no adjust
//****
    CALC    LOAD, -PISTON_MORE_uL
    CSUB    moveCoordPistonREL_uL
//****
returnMoreBack: 
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST  // Set maximum positioning speed
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

bumpPlunger:   // 

    CALC    LOAD, BUMP_DOWN_REL_uL
    CSUB    moveCoordPistonREL_uL
// the piston bump will run in parallel to the vertical down, and wait after start of vertical
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitAfterDraw:

    GGP     GB_DrawWaitTime, GPbank_2              // get time in [100ms]
                  
    WAIT    TICKS, 0, ACCUMULATOR_WAIT             // wait ticks as in A

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveSlowlyBottom:    // 
 
    GGP     GB_BumpPosVert, GPbank_2                  // go to required height
    CALCAV  SUB, GB_DELTA_B                          // sub delta when pointing up (for abs movment in vert)
    CSUB    moveCoordVertical                       // move, wait and error if delay
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rotateDown:   // 

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_ROT // Set maximum positioning speed
    CALC    LOAD, VERTICAL_FOR_ROTATION                    // move head down while "bump"
    CALCAV  SUB, GB_DELTA_B                          // sub delta when rising (in vert)
    MVPA    ABS, M_verticalMotor
    CSUB    waitPiston                                                     // wait for end of bump movement
    CSUB    waitVertical
    SGP     GB_errors_needleInVial, GPbank_2, clr    // erase assume error: the needle is out from the vial
    CSUB    closeVialCover                           // close vial cover
    MVP     COORD, $51, ABOVE_CAP_COORD              // interpolate up and CW to position
    CSUB    waitRotateLong
    CSUB    waitVerticalLong
    CSUB    PositionHeadRotateMotor
    CSUB    adjustNeedleLocaction                    // according to miss location at top
    // // GGP     GB_LoadingHight, GPbank_2                // get reference height
    // // // CALCAV  SUB, GB_Cap_Length_current_us            // add delta for required height
    // // CALCAV  ADD, GB_needleLengthInMicroSteps
    // // CALCAV  ADD, GB_DELTA_B                          // add delta when pointing down (for abs movment in vert) // maybe just go to highest possible location instead ?
    // // MVPA    ABS, M_verticalMotor                     // move to location
    // // CSUB    waitVertical
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

adjustNeedleLocaction:   //  will adjust the needle to the midle of cap CENTER_OF_VIAL

    GGP     GB_NeedleVialError, GPbank_2                        // save error
    CALCX   LOAD                                                // put adjustment in X
    GAP     AP_ActualPosition, M_headRotateMotor
    CALCX   SUB                                                 // now the target is with adjustment 
    CSUB    moveCoordRotate                                     // move, wait and error if delay

 // check if to add to average
    GGP     GB_NeedleVialError, GPbank_2                        // reload error
    COMP    RE_CALC_CENTER_OF_VIAL_LIMIT                        // error greater than limit?
    JC      GE, returnAdjustNeedle                              // yes, do not calculate
    GGP     GB_NeedleVialError, GPbank_2                        // reload error
    COMP    -RE_CALC_CENTER_OF_VIAL_LIMIT                       // error less that than negative limit?
    JC      LE, returnAdjustNeedle                              // yes, do not calculate

 // calculate new Center of vial
 // this will calculate the running average of the center of vial, according to the reading of the sensor.
 // if AVERAGE_CENTER_VIAL_WEIGHT=100:
 // center-of-vial = (old*99+new)/100
 // or:   100*center = 100*old+(new-old)=100*old+error
 // this will be calculated only for small errors
 
    GGP     GB_MulCenterOfVial, GPbank_2                        // load it to A
    CALCX   LOAD
    GGP     GB_NeedleVialError, GPbank_2                        // where was the reference at vial?
    CALCX   ADD
    AGP     GB_MulCenterOfVial, GPbank_2                        // load into current center of vial
    CALC    DIV, AVERAGE_CENTER_VIAL_WEIGHT            
 // not implemented yet. enable 2 following lines to enable
 //   AGP     GB_CenterOfVial, GPbank_2                         // load into current center of vial
 //   STGP    GB_CenterOfVial, GPbank_2                         // load into current center of vial
 
returnAdjustNeedle:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

recapSyringe:   // 

//    CSUB    checkSyrPoppedOut                              // verify that the syringe did not pop out
    CSUB    findCapHolderAtNeedle                          // look for RFS twice and if not found, put in default setting
//    CSUB    checkSyrPoppedOut                              // verify that the syringe did not pop out
 
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_INTO_CAP   // Set slow positioning speed
    CALC    LOAD, VERTICAL_BACK_TO_CENTER  // move head down into cap, where we adjust back to center 
    CALCAV  ADD, GB_DELTA_B                          // add delta when pointing down (for abs movment in vert) // maybe just go to highest possible location instead ?
    MVPA    ABS, M_verticalMotor
    CSUB    waitVertical
 // moving head and cap holder to center
//    CSUB    checkSyrPoppedOut                              // verify that the syringe did not pop out
    GGP     GB_HeadRotateHomePos, GPbank_2                 // go back to loading position
    MVPA    ABS, M_headRotateMotor                         // move, wait later
    GGP     GB_CapHoldsSyringe, GPbank_2                   // go back to loading position
    MVPA    ABS, M_capHolderMotor                          // move, wait later
    CSUB    waitRotate                                     // wait and error if delay
    CSUB    waitCapHolder                                  // wait both axis to save time
//    CSUB    checkSyrPoppedOut                              // verify that the syringe did not pop out
 // now down to loading hight
 // VERTICAL_CAP_VIBRATE_DELTA um before loading 
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_INTO_CAP/2 // Set slower positioning speed
    GGP     GB_LoadingHight, GPbank_2
    CALCAV  ADD, GB_DELTA_A
    CALC    SUB, VERTICAL_CAP_VIBRATE_DELTA * verticalMicroStepsPerMM / 1000  // A will hold the location above loading position
    CSUB    moveCoordVertical
 // 0.3 mm below loading
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_INTO_CAP/6 // Set slower positioning speed
    GGP     GB_LoadingHight, GPbank_2
    CALCAV  ADD, GB_DELTA_A
    CALC    ADD, verticalMicroStepsPerMM * 3 / 10         // push 0.3 mm unto the cap 
    MVPA    ABS, M_verticalMotor                          // move, wait later
    CSUB    waitVertical
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_ROT// Set high positioning speed

    SGP     GB_inHomeCapHolderMotor, GPbank_2, set       // in interrupt sub enable 3 times checking if syringe popped out + re homing
    CSUB    homeCapHolderMotor
    SGP     GB_inHomeCapHolderMotor, GPbank_2, clr
    
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

findCapHolderAtNeedle:         
// any change in this function needs to be changed in "findCenterCapHolderManual" as well

    GGP     GB_LoadingHight, GPbank_2               // get reference height
    CALC    ADD, DECAP_HEIGHT_DELTA                  // add delta for required height
    CALCAV  ADD, GB_DELTA_B                          // add delta when pointing down (for abs movment in vert)
    MVPA    ABS, M_verticalMotor                     // move to location
    CSUB    waitVertical

    GGP     GB_CapHoldsSyringe, GPbank_2                    // get center of cap holder
    CALC    ADD, CAP_HOLDER_RELATIVE_RFS                    // 40 add relative cap holder location, start of RFS
    CSUB    moveCoordCapHolder                              // move, wait and error if delay

// cap holder looks for the home ref sensor. 
// This sensor senses the needle and positions exactely
    SAP     AP_RefSearchSpeed, M_capHolderMotor, SEARCH_SPEED_CAP_SLOW   // speed for search
    SAP     AP_RefSwitchSpeed, M_capHolderMotor, SWITCH_SPEED_CAP_SLOW   // speed for final search
    SAP     AP_RefSearchMode, M_capHolderMotor, APV_RefHomeLeft + AVP_ReverseHomePolarity // search needle  
    RFS     START, M_capHolderMotor                          // Start reference search
    WAIT    RFS, M_capHolderMotor, WAIT_CAP_REF              // wait till reaches location or 0.8 seconds
    JC      ETO, gotoCapHoldsSyringe                         // timeout occured
    GAP     AP_LastRefPosition, M_capHolderMotor             // get position of reference
    AAP     AP_ActualPosition, M_capHolderMotor              // copy into current location, because was cleared by RFS
    GGP     GB_NeedleAtCapOffset, GPbank_2                   // get rel center of cap holder
    MVPA    REL, M_capHolderMotor                            // move cap holder to center of needle
    CSUB    waitCapHolder
//checkBent:
    CSUB    checkCapBentLimit                                // if more than limit, stop ABORT
    JA      endcapHolder

gotoCapHoldsSyringe:
    RFS     STOP, M_capHolderMotor                           // Stop reference search
    WAIT    RFS, M_capHolderMotor, WAIT_CAP_REF              // wait till reaches location or 0.8 seconds
    GGP     GB_CapHoldsSyringe, GPbank_2                     // go to required angle
    CSUB    moveCoordCapHolder                               // move, wait and error if delay

endcapHolder:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkCapBentLimit:

    GAP     AP_ActualPosition, M_capHolderMotor         // get current position
    CALCX   LOAD                                        // copy current to X
    GGP     GB_CapHoldsSyringe, GPbank_2                // load center location of cap
    CALCX   SUB
    CALCX   LOAD                                        // copy adjustment to X                
    AGP     GB_NeedleCapError, GPbank_2                 // save error
    COMP    limitCapBentMicroS                          // error greater than limit?
    JC      GE, stopCapLimitBentNeedle                  // yes, do not calculate
    GGP     GB_NeedleCapError, GPbank_2                 // reload error
    COMP    -limitCapBentMicroS                         // error less that than negative limit?
    JC      LE, stopCapLimitBentNeedle
    JA      returnCheckCapBentLimit

stopCapLimitBentNeedle:
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_needleBentCap                     // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR
    JA      ABORT_NoReport

returnCheckCapBentLimit:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

findCenterCapHolderManual:
// any change in this function needs to be changed in "findCapHolderAtNeedle" as well

 // check state
    GGP     GB_CurrentState, GPbank_2               // current state to A
    COMP    WAITING_DRAW_DOSE                       // initialization done
    JC      NE, okFindCenterCap                     // if EQ, continue

    GGP     GB_LoadingHight, GPbank_2               // get reference height
    CALC    ADD, DECAP_HEIGHT_DELTA                  // add delta for required height
    CALCAV  ADD, GB_DELTA_B                          // add delta when pointing down (for abs movment in vert)
    MVPA    ABS, M_verticalMotor                     // move to location
    CSUB    waitVertical

    GGP     GB_CapHoldsSyringe, GPbank_2            // get center of cap holder
    CALC    ADD, CAP_HOLDER_RELATIVE_RFS            // 40 add relative cap holder location
    CSUB    moveCoordCapHolder                      // move, wait and error if delay

    SAP     AP_RefSearchSpeed, M_capHolderMotor, SEARCH_SPEED_CAP_SLOW   // speed for search
    SAP     AP_RefSwitchSpeed, M_capHolderMotor, SWITCH_SPEED_CAP_SLOW   // speed for final search
    SAP     AP_RefSearchMode, M_capHolderMotor, APV_RefHomeLeft + AVP_ReverseHomePolarity   // search needle  
    RFS     START, M_capHolderMotor                                      // Start reference search
    WAIT    RFS, M_capHolderMotor, WAIT_CAP_REF                          // wait till reaches location or 0.8 seconds
    JC      ETO, rfsCapError                                             // timeout occured
    GAP     AP_LastRefPosition, M_capHolderMotor                         // get position of reference
    AAP     AP_ActualPosition, M_capHolderMotor                          // copy into current location because was cleared
    GGP     GB_NeedleAtCapOffset, GPbank_2                               // get rel center of cap holder
    MVPA    REL, M_capHolderMotor                                        // move cap holder to center of needle
    CSUB    waitCapHolder
    JA      okFindCenterCap 
rfsCapError:
    CSUB    RED_ON
okFindCenterCap:    
   RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

insertIntoDozeCalib:   // 

    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT_INTO_CALIBRATOR // Set absolute max. current
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_DOWN  // Set maximum positioning speed
    GGP     GB_inDoseCalibrator, GPbank_2                                    // go to required height

    SGP     GB_MotorIsMoving, GPbank_2, set
    MVPA    ABS, M_verticalMotor                                             // move, wait later
    WAIT    POS, M_verticalMotor, WAIT_TICKS_LONG                            // wait till reaches location or 15 seconds
    JC      ETO, InDoseCalibratorTOerr                                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT                 // Set absolute max. current
//    CSUB    checkSyrPoppedOut                                              // verify that the syringe did not pop out
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ExtractFromDoseCalibrator:   // 

    GAP     AP_ActualPosition, M_verticalMotor
    CALC    SUB, MIN_DEPTH_FOR_EXTRACT              // AP_ActualPosition - MIN_DEPTH_FOR_EXTRACT. if > 0, low enough
    COMP    0                     
    JC      LT, exitExtractDC  
 
    CSUB    homeCapHolderMotor
    CSUB    homePigHolderMotor               // Pig and Cap holders first to clear the way for vertical
// open piston 0.2 mL
    MVP     REL, M_pistonMotor, GB_pistonMicroStepPer100microL*2               // pull 0.2 mL
    CSUB    waitPiston

    CSUB    homeVerticalMotor

exitExtractDC:
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE                  // signals that retreat is done and ready to initialyze
    SGP     GB_retreatMovementComplete, GPbank_2, set          // signals end of retreat movement. will be cleared on the next cycle
    DI      TI_STOPLEFT4                                       //  Left rotate reference
    DI      TI_STOPLEFT5                                       //  syringe pop out interrupt
    DI      TI_STOPRIGHT5
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

putSyringeInPig:    // 

    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT_HIGH           // Set absolute max. current
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
    SGP     GB_TouchedLeftRef, GPbank_2, clr                                // wait for set interrupt when going up
    EI      TI_STOPLEFT4                                                    // touched interrupt
    CALC    LOAD, ABOVE_PIG
    // CALCAV  ADD, GB_DELTA_C                                                 // add delta when pointing down (for abs movment in vert) // maybe just go to highest possible location instead ?
    MVPA    ABS, M_verticalMotor                                            // run to position move above PIG
    CSUB    waitVerticalLong
 // check if touched sensor
    GGP     GB_TouchedLeftRef, GPBank_2                                     // check if touched ref sensor
    COMP    set                                                             // touched?
    JC      NE, verticalMotorTOerr                                          // if not, stop and error
    DI      TI_STOPLEFT4                                                    // touched interrupt
    CSUB    squeezeCap                         ///
    CSUB    checkCapOnSyringe                  ///
    GGP     GB_PigBelowSyringe, GPbank_2                                    // go to required height
    CSUB    moveCoordPigHolder                                              // move, wait and error if delay
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_TO_PIG // Set maximum positioning speed
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT                // Set absolute max. current
    MVP     ABS, M_verticalMotor, IN_PIG                                    // put down into PIG
    CSUB    waitVertical
    DI      TI_STOPLEFT5                                                    //  syringe pop out interrupt
    CSUB    HomePigHolderMotor                                              // pop out the PIG holder
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

squeezeCap:

    MVP     ABS, M_verticalMotor, ABOVE_SQUEEZE_CAP
    CSUB    waitVertical
    GGP     GB_RecapPositionPig, GPbank_2
    CSUB    moveCoordPigHolder                                              // move, wait and error if delay
    MVP     REL, M_pigHolderMotor, SQUEEZE_CAP_ON_PIG_DELTA                    
    CSUB    waitPigHolder
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_INTO_CAP // Set maximum positioning speed
    GGP     GB_squeezeCapHeight, GPbank_2                        // go to required height
    CALCAV  ADD, GB_DELTA_C
    CSUB    moveCoordVertical                                               // move, wait and error if delay
    MVP     REL, M_verticalMotor, DETECT_CAP_HIGHT_REL                      // moves up 1 mm to release the pig holder                   
    CSUB    waitVertical
    CSUB    HomePigHolderMotor                                              // pop out the PIG holder
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkCapOnSyringe:

    GGP     GB_CapHoldsSyringe, GPbank_2                // get center of cap holder which means, the sensor is GB_NeedleAtCapOffset outwards
//    CALCAV  SUB, GB_NeedleAtCapOffset                // subtract the offeset between the sensor an the needle, so sensor is on HOME
    CSUB    moveCoordCapHolder                        // move, wait and error if delay
// first check
    GIO     In_CapHolderHomeNeedle, InBankDigital_0     // is the CAP detected?
    COMP    CAP_SENSOR_BLOCKED
    JC      EQ, returnCheckCAP                        // cap exists
// second check
    MVP     REL, M_capHolderMotor, -STEPS_FOR_CAPS_SENSING
    CSUB    waitCapHolder
    GIO     In_CapHolderHomeNeedle, InBankDigital_0     // is the CAP detected?
    COMP    CAP_SENSOR_BLOCKED
    JC      EQ, returnCheckCAP                        // cap exists
// third check
    MVP     REL, M_capHolderMotor, -STEPS_FOR_CAPS_SENSING
    CSUB    waitCapHolder
    GIO     In_CapHolderHomeNeedle, InBankDigital_0   // is the CAP detected?
    COMP    CAP_SENSOR_BLOCKED
    JC      EQ, returnCheckCAP                        // cap exists
// No cap detected 3 times
    CSUB    lookForBentSyringe                        // make now 5 more measurements. 
    SGP     GB_syringeWOcapInPIG, GPbank_2, set       // the syringe in the PIG has no cap
returnCheckCAP:
    MVP     ABS, M_verticalMotor, ABOVE_PIG           // run to position move above PIG
    CSUB    waitVertical
    CSUB    homeCapHolderMotor                        // cap holder out of the way
    RSUB


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

lookForBentSyringe:      // syringe bent then we put syringe manully into PIG

// forth check
    MVP     REL, M_capHolderMotor, -STEPS_FOR_CAPS_SENSING
    CSUB    waitCapHolder
    GIO     In_CapHolderHomeNeedle, InBankDigital_0     // is the CAP detected?
    COMP    CAP_SENSOR_BLOCKED                          // YES, ERROR
    JC      EQ, reportError                             // cap exists
// fifth check
    MVP     REL, M_capHolderMotor, -STEPS_FOR_CAPS_SENSING
    CSUB    waitCapHolder
    GIO     In_CapHolderHomeNeedle, InBankDigital_0     // is the CAP detected?
    COMP    CAP_SENSOR_BLOCKED                          // YES, ERROR
    JC      EQ, reportError                             // cap exists
// sixth check
    MVP     REL, M_capHolderMotor, -STEPS_FOR_CAPS_SENSING
    CSUB    waitCapHolder
    GIO     In_CapHolderHomeNeedle, InBankDigital_0     // is the CAP detected?
    COMP    CAP_SENSOR_BLOCKED                          // YES, ERROR
    JC      EQ, reportError                             // cap exists
// seventh check
    MVP     REL, M_capHolderMotor, -STEPS_FOR_CAPS_SENSING
    CSUB    waitCapHolder
    GIO     In_CapHolderHomeNeedle, InBankDigital_0     // is the CAP detected?
    COMP    CAP_SENSOR_BLOCKED                          // YES, ERROR
    JC      EQ, reportError                             // cap exists
// eights check
    MVP     REL, M_capHolderMotor, -STEPS_FOR_CAPS_SENSING
    CSUB    waitCapHolder
    GIO     In_CapHolderHomeNeedle, InBankDigital_0     // is the CAP detected?
    COMP    CAP_SENSOR_BLOCKED                          // YES, ERROR
    JC      NE, noCapFound                              // cap exists
reportError:
    GGP     GB_errors_Ver002, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_bentCapBeforePIG                  // add the error bit
    AGP     GB_errors_Ver002, GPbank_2                  // and write again
    STGP    GB_errors_Ver002, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR
    JA      ABORT_NoReport
noCapFound:    // just continue putting syringe in PIG
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

capIntoCapHolder:

 // go via home sensor
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT_HIGH             // Set absolute max. current
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH   // Set maximum positioning speed
    SGP     GB_TouchedLeftRef, GPbank_2, clr                                  // wait for set interrupt when going up
    EI      TI_STOPLEFT4                                                      // touched interrupt
    MVP     ABS, M_verticalMotor, UP_FOR_SENSOR_ABS                           // run to position move to rotate sensor for interrupt
    CSUB    waitVertical
    GGP     GB_LoadingHight, GPbank_2                                         // go to required height
    CALCAV  ADD, GB_DELTA_A
    MVPA    ABS, M_verticalMotor                                              // run to above PIG
    CSUB    waitVertical
 // check if touched sensor
    GGP     GB_TouchedLeftRef, GPBank_2                                       // check if touched ref sensor
    COMP    set                                                               // touched?
    JC      NE, verticalMotorTOerr                                            // if not, stop and error
    DI      TI_STOPLEFT4                                                      // touched interrupt

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, SEARCH_SPEED_VERT        // Set maximum positioning speed
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT                  // Set absolute max. current
//    CSUB    checkSyrPoppedOut                                      // verify that the syringe did not pop out
    GGP     GB_RecapPositionPig, GPbank_2                          // go to required height
    CSUB    moveCoordPigHolder                                     // move, wait and error if delay
//    CSUB    checkSyrPoppedOut                                      // verify that the syringe did not pop out
    GGP     GB_CapHoldsSyringe, GPbank_2                           // go to required height
    CSUB    moveCoordCapHolder                                     // move, wait and error if delay
//    CSUB    checkSyrPoppedOut                                      // verify that the syringe did not pop out
    CSUB    homePigHolderMotor                                     // get pig out
    RSUB
    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

clrErrors_wrong_PC_command:

    SGP     GB_errors_wrong_PC_command, GPbank_2, clr
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

incrementAdjustments:
    GGP     GB_adjustmentsTotal, GPbank_2                   // cycles so far into A
    CALC    ADD, 1                                          // add 1 to accumulator
    AGP     GB_adjustmentsTotal, GPbank_2                   // A to Global parameter
    //STGP    GB_adjustmentsTotal, GPbank_2                   // store it in EEPROM
    RSUB 

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

incrementCycles:
    GGP     GB_cyclesTotal, GPbank_2                   // cycles so far into A
    CALC    ADD, 1                                     // add 1 to accumulator
    AGP     GB_cyclesTotal, GPbank_2                   // A to Global parameter
    STGP    GB_cyclesTotal, GPbank_2                   // store it in EEPROM
    RSUB 

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Manual Axis movements 
//  Use carefully, only in direct mode
//  The movement consists of the following commands.
//  The global parameter GP_uPulsesManual (address 19)  holds the micro-meters 
//  or mili-degrees to go, which can be negative or positive.
//  Before sending the next movement look if GB_MotorIsMoving (GB_16) is clear
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

VerticalManual:    // 

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [uMeter] into A
    CALC    MUL, verticalMicroStepsPerMM              
    CALC    DIV, 1000                                   // now in uSteps
    CALCX   LOAD                                        // move it to X [uStep]
    GAP     AP_ActualPosition, M_verticalMotor          // get current position to A
    CALCX   ADD                                         // add current position to required relative
    ACO     VERTICAL_POS_COORD, M_verticalMotor         // target position into coordinate
    MVP     COORD, M_verticalMotor, VERTICAL_POS_COORD  // run to coord position
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_verticalMotor, WAIT_TICKS_SHORT      // wait till reaches location or 2 seconds
    JC      ETO, verticalMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB    

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveCoordVertical:    // 

    MVPA    ABS, M_verticalMotor                         // move, wait later
    CSUB    waitVertical
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitVertical:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_verticalMotor, WAIT_TICKS            // wait till reaches location or 10 seconds
    JC      ETO, verticalMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitVerticalLong:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_verticalMotor, WAIT_TICKS_LONG        // wait till reaches location or 15 seconds
    JC      ETO, verticalMotorTOerr                      // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitVerticalRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_verticalMotor, WAIT_TICKS_LONG         // wait end of reference search 15 seconds
    JC      ETO, verticalMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PigHolderManual:    // 

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [mDeg] into A
    CALC    MUL, pigMicrostepsPerDeg                
    CALC    DIV, 1000                                   // now in mDeg
    CALCX   LOAD                                        // move it to X
    GAP     AP_ActualPosition, M_pigHolderMotor         // get current position to A
    CALCX   ADD                                         // add current position to required relative
    ACO     PIG_POS_COORD, M_pigHolderMotor             // target position into coordinate
    MVP     COORD, M_pigHolderMotor, PIG_POS_COORD      // run to coord position
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pigHolderMotor, WAIT_TICKS_SHORT     // wait till reaches location or 2 second
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB    

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveCoordPigHolder:    // 

    MVPA    ABS, M_pigHolderMotor                         // move, wait later
    CSUB    waitPigHolder
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitPigHolder:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pigHolderMotor, WAIT_TICKS           // wait till reaches location or 10 seconds
    JC      ETO, pigMotorTOerr                          // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitPigHolderRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_pigHolderMotor, WAIT_TICKS           // wait end of reference search 15 seconds
    JC      ETO, pigMotorTOerr                          // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CapHolderManual:    // 

    SAP     AP_StandbyCurrent, M_capHolderMotor, STBY_CUR_CAP_HIGH      // Set standby current
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [mDeg] into A
    CALC    MUL, capMicrostepsPerDeg                
    CALC    DIV, 1000                                   // now in mDeg
    CALCX   LOAD                                        // move it to X 
    GAP     AP_ActualPosition, M_capHolderMotor         // get current position to A
    CALCX   ADD                                         // add current position to required relative
    ACO     CAP_POS_COORD, M_capHolderMotor             // target position into coordinate
    MVP     COORD, M_capHolderMotor, CAP_POS_COORD      // run to coord position
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_capHolderMotor, WAIT_TICKS_SHORT     // wait till reaches location or 2 seconds
    JC      ETO, capHolderMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveCoordCapHolder:    // 

    MVPA    ABS, M_capHolderMotor                         // move, wait later
    CSUB    waitCapHolder
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitCapHolder:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_capHolderMotor, WAIT_TICKS            // wait till reaches location or 10 seconds
    JC      ETO, capHolderMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitCapHolderRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_capHolderMotor, WAIT_TICKS           // wait end of reference search 15 seconds
    JC      ETO, capHolderMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PistonManual:    // 

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [uMeter] into A
    CALC    MUL, pistonMicroStepsPerMM           
    CALC    DIV, 1000                                   // now in uSteps
    CALCX   LOAD                                        // move it to X [uStep]
    GAP     AP_ActualPosition, M_pistonMotor            // get current position to A
    CALCX   ADD                                         // add current position to required relative
    ACO     PISTON_POS_COORD, M_pistonMotor             // target position into coordinate
    MVP     COORD, M_pistonMotor, PISTON_POS_COORD      // run to coord position
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pistonMotor, WAIT_TICKS_SHORT        // wait till reaches location or 2 seconds
    JC      ETO, pistonMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveCoordPiston:    //

    COMP    0
    JC      GE, pistCoordAreAboveMin
    CALC    LOAD, 0
pistCoordAreAboveMin:
    CALCAV  MUL, GB_PistonFactor                                  // calc factor for adjustment of difference between machine (100 is no change)
    CALC    DIV, 100
    COMP    MAX_PIST_IN_USTEPS
    JC      LE, pistUSeptsInRange
    CALC    LOAD, MAX_PIST_IN_USTEPS
pistUSeptsInRange:
    MVPA    ABS, M_pistonMotor                        // move, wait later
    CSUB    waitPiston
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveCoordPiston_uL:    // 

    CALCAV  MUL, GB_pistonMicroStepPer100microL          
    CALC    DIV, 100                                                        // now in uSteps
    CALCAV  ADD, GB_PistonHomePos                                           // go relative to starting position    
    CALCAV  SUB, GB_DELTA_D                                         // adjust Thumbrest location from the finger flange in difrenet syringes
    CSUB    moveCoordPiston
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveCoordPistonREL_uL:    // 

    CALCAV  MUL, GB_pistonMicroStepPer100microL          
    CALC    DIV, 100                                                        // now in uSteps
    CSUB    moveCoordPistonREL
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveCoordPistonREL:    // 

// GB_current_Volume_Temp_saver = 165

    CALCAV  MUL, GB_PistonFactor                                  // calc factor for adjustment of difference between machine (100 is no change)
    CALC    DIV, 100

    CALCVA  LOAD, GB_current_Volume_Temp_saver
    GAP     AP_ActualPosition, M_pistonMotor            // get current position of piston
    CALCAV  ADD, GB_current_Volume_Temp_saver
    COMP    MAX_PIST_IN_USTEPS
    JC      LE, RELpistUSeptsInRange
    CALC    LOAD, MAX_PIST_IN_USTEPS
    CSUB    moveCoordPiston
    JA      RELpistUSeptsAdjusted
RELpistUSeptsInRange: 
    CALCAV  LOAD, GB_current_Volume_Temp_saver   
                                                                                                                                                
                    
    MVPA    REL, M_pistonMotor                        // move, wait later
                    
    CSUB    waitPiston
RELpistUSeptsAdjusted:
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitPiston:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pistonMotor, WAIT_TICKS              // wait till reaches location or 10 seconds
    JC      ETO, pistonMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitPistonRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_pistonMotor, WAIT_TICKS             // wait end of reference search 15 seconds
    JC      ETO, pistonMotorTOerr                      // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

RotationManual:    // 

    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH  // Set standby current 
    SAP     AP_LeftLimitSwitchDisable, M_headRotateMotor, set           // Disable left limit switch
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [mDeg] into A
    CALC    MUL, rotateMicrostepsPerDeg                 // 
    CALC    DIV, 1000                                   // now in mDeg
    CALCX   LOAD                                        // move it to X 
    GAP     AP_ActualPosition, M_headRotateMotor        // get current position to A
    CALCX   ADD                                         // add current position to required relative
    ACO     ROTATE_POS_COORD, M_headRotateMotor         // target position into coordinate
    MVP     COORD, M_headRotateMotor, ROTATE_POS_COORD  // run to coord position
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_headRotateMotor, WAIT_TICKS_SHORT    // wait till reaches location or 2 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveCoordRotate:    // 

    MVPA    ABS, M_headRotateMotor                        // move, wait later
    CSUB    waitRotate
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotate:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_headRotateMotor, WAIT_TICKS          // wait till reaches location or 10 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateLong:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_headRotateMotor, WAIT_TICKS_LONG     // wait till reaches location or 10 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_LONG     // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfsShort:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_SHORT   // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                  // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfsNeedleSecond:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_NEEDLE_REF_SECOND   // wait end of reference search 5.5 seconds
    JC      ETO, RotateTimeout                               // timeout occured
    JA      returnWaitRotateRfsNeedleSecond                  // no timeout 
RotateTimeout:
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE   // signals that RFS is done and ready to initialyze
    CSUB    setAnyError
    GGP     GB_errors_M_headRotateMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                            // add the error bit
    AGP     GB_errors_M_headRotateMotor, GPbank_2        // and write again
    STGP    GB_errors_M_headRotateMotor, GPbank_2        // and store it
    JA      ABORT_NoReport
returnWaitRotateRfsNeedleSecond:
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  calibration functions  
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HomeCalibration:

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_verticalMotor
    JC      EQ, calibMotorVertical

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_pigHolderMotor
    JC      EQ, calibMotorPig

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_capHolderMotor
    JC      EQ, calibMotorCap

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_pistonMotor
    JC      EQ, calibMotorPiston

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_headRotateMotor
    JC      EQ, calibMotorRotate
    JA     returnHomeCalibration

calibMotorVertical:
    CSUB   homeVerticalMotor
    JA     returnHomeCalibration

calibMotorPig:
    CSUB   homePigHolderMotor
    JA     returnHomeCalibration

calibMotorCap:
    CSUB   homeCapHolderMotor
    JA     returnHomeCalibration

calibMotorPiston:
    CSUB   homePistonMotor
    JA     returnHomeCalibration

calibMotorRotate:
    CSUB   HomeHeadRotateMotor
//    JA     returnHomeCalibration

returnHomeCalibration:
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setCenterOfSeptum:

    GAP     AP_ActualPosition, M_headRotateMotor
    COMP    31500                                        // syringe holder should be on the vial sensor
    JC      GT, atCorrectAngle  
  // location error
    GGP     GB_errors_M_headRotateMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_calibrationErr                     // add the error bit
    AGP     GB_errors_M_headRotateMotor, GPbank_2        // and write again
    STGP    GB_errors_M_headRotateMotor, GPbank_2        // and store it
    CSUB    setStateSTOPPED_ON_ERROR
    JA      ABORT_NoReport

atCorrectAngle:
    GGP     GB_HeadRotateHomePos, GPbank_2         // where was the cap location (80)
    CALC    ADD, HEAD_ROTATE_NEEDLE_SEARCH         // add current rotation location 
    CSUB    moveCoordRotate                        // move, wait and error if delay
    CSUB    findCenterOfNeedleSensor               // find the center of the sensor
    GGP     GB_lastTopRefPosition, GPbank_2        // where was the location?
//    AGP     GB_CenterOfVial, GPbank_2            // set the global parameter
//    STGP    GB_CenterOfVial, GPbank_2
    AAP     AP_ActualPosition, M_headRotateMotor   // set the axis parameter

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DoseCalibratorCheck:     // if no syringe on holder, move the arm out and rotate right to enable checking

 // check syringe
    CSUB    checkNoSyringe                   // check syringe exists, sets STOPPED_ON_ERROR state
    GGP     GB_any_Error, GPbank_2           // get any error status
    COMP    ANY_ERROR_EXISTS                 // exists?
    JC      EQ, returnDoseCalibCheck         // error, return             
 // check state
    GGP     GB_CurrentState, GPbank_2                      // current state to A
    COMP    WAITING_DRAW_DOSE                              // initialization complete?
    JC      EQ, okClearCalibrator                          // if EQ, continue
    // syringe found, signal errors
    GGP     GB_errors_wrong_PC_command, GPbank_2           // load  error word
    CALC    OR, BitEr_expecting_WAITING_DRAW_DOSE          // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2           // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2           // and store it
    CSUB    setAnyErrorYellow
    JA      returnDoseCalibCheck

okClearCalibrator:    

    CSUB    homeCapHolderMotor
    CSUB    homePigHolderMotor                       // Pig and Cap holders first to clear the way for vertical
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT_HIGH           // Set absolute max. current
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
    GGP     GB_VerticalHomePos, GPbank_2 
    CSUB    moveCoordVertical                                     // move, wait and error if delay
    MVP     ABS, M_headRotateMotor, HEAD_ROTATE_CALIBRATOR_CHECK  // go to 90 degrees right
    CSUB    waitRotateLong
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT      // Set absolute max. current back
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
 
returnDoseCalibCheck:
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

armIntoDoseCalibrator:

 // check syringe
    CSUB    checkNoSyringe                   // check syringe exists, sets STOPPED_ON_ERROR state
    GGP     GB_any_Error, GPbank_2           // get any error status
    COMP    ANY_ERROR_EXISTS                 // exists?
    JC      EQ, returnArmInDoseCalibrator    // error, return             
 // check state
    GGP     GB_CurrentState, GPbank_2                      // current state to A
    COMP    WAITING_DRAW_DOSE                              // initialization complete?
    JC      EQ, okArmInDoseCalibrator                      // if EQ, continue
    // syringe found, signal errors
    GGP     GB_errors_wrong_PC_command, GPbank_2           // load  error word
    CALC    OR, BitEr_expecting_WAITING_DRAW_DOSE          // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2           // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2           // and store it
    CSUB    setAnyErrorYellow
    JA      returnArmInDoseCalibrator

okArmInDoseCalibrator:    
    CSUB    homeCapHolderMotor
    CSUB    homePigHolderMotor               // Pig and Cap holders first to clear the way for vertical
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT_HIGH           // Set absolute max. current
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_DOWN // Set maximum positioning speed
    GGP     GB_inDoseCalibrator, GPbank_2                         // go to required height
    MVPA    ABS, M_verticalMotor                                  // move, wait later
    CSUB    waitVerticalLong
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT      // Set absolute max. current back

returnArmInDoseCalibrator:
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

retreatFromVial:

//  verify that the hight is above bump - 10mm
    GAP     AP_ActualPosition, M_verticalMotor
    CALCAV  SUB, GB_BumpPosVert              // AP_ActualPosition - ( GB_BumpPosVert - DELTA_B ). if >0, below bump
    CALCAV  ADD, GB_DELTA_B                  // actual - ( bump - delta )
    COMP    verticalMicroStepsPerMM * 10     // 10 mm below bump is OK
    JC      GT, locationError  
//  verify that the hight is below bump + ABOVE_BUMP + 1 (9mm)
    GAP     AP_ActualPosition, M_verticalMotor
    CALCAV  SUB, GB_BumpPosVert              // AP_ActualPosition - ( GB_BumpPosVert - DELTA_B ). if >0, below bump
    CALCAV  ADD, GB_DELTA_B                  // actual - ( bump - delta )
    COMP    -verticalMicroStepsPerMM * (ABOVE_BUMP +1) // >10 mm above bump is bad
    JC      GT, atCorrectHight  
locationError:
    GGP     GB_errors_M_verticalMotor, GPbank_2        // load vertical error word
    CALC    OR, BitEr_retreatFromVialErr               // add the error bit
    AGP     GB_errors_M_verticalMotor, GPbank_2        // and write again
    STGP    GB_errors_M_verticalMotor, GPbank_2        // and store it
    CSUB    setAnyError
    JA      returnRetreatFromVial
atCorrectHight:
// clear the way for vertical
    CSUB    homeCapHolderMotor
    CSUB    homePigHolderMotor               // Pig and Cap holders first to clear the way for vertical
// move vertical down under bump
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT / 2               // Set absolute max. current
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_TO_VIAL // Set maximum positioning speed very slow
    GGP     GB_BumpPosVert, GPbank_2                                           // go to required height
    CALCAV  SUB, GB_DELTA_B                                                    // sub delta when pointing up (for abs movment in vert)
    MVPA    ABS, M_verticalMotor                                               // move to bump
    CSUB    waitVerticalLong
// open piston
    MVP     REL, M_pistonMotor, GB_pistonMicroStepPer100microL*1               // pull 0.1 mL
    CSUB    waitPiston
// move vertical down to rotation hight
    CALC    LOAD, VERTICAL_FOR_ROTATION
    CALCAV  SUB, GB_DELTA_B
    MVPA    ABS, M_verticalMotor                                               // move, wait later
    CSUB    waitVertical
    CSUB    closeVialCover
    SAP     AP_MaxCurrent, M_verticalMotor, MAX_CURRENT_VERT                   // Set absolute max. current back
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_RETREAT // Set maximum positioning speed very slow
    MVP     ABS, M_verticalMotor,VERTICAL_FOR_RETRETE                          // move down to escaoe syringe ane sheet metal crash
    CSUB    waitVerticalLong
    SAP     AP_MaxPositioningSpeed, M_headRotateMotor, SEARCH_SPEED_ROT        // Set maximum positioning speed very slow
    MVP     REL, M_headRotateMotor, FROM_TOP_TO_RIGHT                          // go to 90 degrees right
    CSUB    waitRotateLong
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE                  // signals that retreat is done and ready to initialyze

returnRetreatFromVial:
//    SGP     GB_initialVolume, GPbank_2, 0                      // reset initial volume [uL]
    SGP     GB_retreatMovementComplete, GPbank_2, set          // signals end of retreat movement. will be cleared on the next cycle
//    DI      TI_TIMER0  
    DI      TI_STOPLEFT4                                       //  Left rotate reference
    DI      TI_STOPLEFT5                                       //  syringe pop out interrupt
    DI      TI_STOPRIGHT5                                      //  dipper interrupt
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setStateSTOPPED_ON_ERROR:

    SGP     GB_CurrentState, GPbank_2, STOPPED_ON_ERROR
    STGP    GB_CurrentState, GPbank_2
    CSUB    setAnyError
    RSUB
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setStateSTOPPED_ON_ERROR_Yellow:

    SGP     GB_CurrentState, GPbank_2, STOPPED_ON_ERROR
    STGP    GB_CurrentState, GPbank_2
    CSUB    setAnyErrorYellow
    RSUB
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setAnyError:

    SGP     GB_any_Error, GPbank_2, set                  // signal error: general
    STGP    GB_any_Error, GPbank_2                       // declare any error  
    CSUB    RED_ON
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setAnyErrorYellow:

    SGP     GB_any_Error, GPbank_2, set                  // signal error: general
    STGP    GB_any_Error, GPbank_2                       // declare any error  
    CSUB    YELLOW_ON
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

clrAnyError:

    SGP     GB_any_Error, GPbank_2, clr                  // signal error: general
    STGP    GB_any_Error, GPbank_2                       // declare any error  
    CSUB    GREEN_ON
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
               


        
                                                                              
                


        
                                                                              
                

                        

        
                                                                              
                

                    
                            

        
